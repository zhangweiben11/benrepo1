<?xml version="1.1" encoding="UTF-8"?>
<!-- salt:4eac6a34-df40-4265-b123-32a6ac34cac2 -->
<metadata name="MonitorServer_CreateDrop_DV_SERVER_SYSTEM_EVENT" path="/shared/CoE/MonitorServer/Datasources/InitializeTable/CreateDropTables/MonitorServer_CreateDrop_DV_SERVER_SYSTEM_EVENT" type="PROCEDURE" subtype="SQL_SCRIPT_PROCEDURE" changeToken="0">
  <annotation><![CDATA[
&#x9;(c) 2017 TIBCO Software Inc.  All rights reserved.
&#x9;
&#x9;Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
&#x9;The details can be found in the file LICENSE.
&#x9;
&#x9;The following proprietary files are included as a convenience, and may not be used except pursuant
&#x9;to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
&#x9;csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
&#x9;csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
&#x9;and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
&#x9;are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
&#x9;
&#x9;This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
&#x9;If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
&#x9;agreement with TIBCO.

]]></annotation>
  <parameters>
    <parameter name="destroyResources" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="createResources" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="datasourceType" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="datasourcePath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="catalogName" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="schemaName" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="packagedQueryPath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="displayDDL" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="executeDDL" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="dropIndexes" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="dropTables" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="dropSequences" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="createTables" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="createIndexes" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="createSequences" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="result" direction="OUT" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="cursCombinedResult" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="sqlScript" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
  </parameters>
  <security>
    <owner user="admin" domain="composite"/>
  </security>
  <dependency target="/lib/debug/Print" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="textToPrint" direction="IN">
        <datatype referenceDefinitionSet="/lib/util/System" referenceType="Text" type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/lib/resource/ResourceExists" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="path" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourcePath" type="STRING" maxLength="4096"/>
      </element>
      <element name="type" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourceType" type="STRING" maxLength="40"/>
      </element>
      <element name="version" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourceVersion" type="STRING" maxLength="255"/>
      </element>
      <element name="exists" direction="OUT">
        <datatype type="BOOLEAN"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/RepoUtils/applyReservedListToPath" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="inPath" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="debug" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/createAllFoldersPrivileges" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="inSourceFolderPath" direction="IN">
        <datatype referenceDefinitionSet="/shared/ASAssets/Utilities/TypeDefinitions" referenceType="pathType" type="STRING" maxLength="4000"/>
      </element>
      <element name="updatePrivilegesRecursively" direction="IN">
        <datatype type="INTEGER" minValue="0" maxValue="1"/>
      </element>
      <element name="copyPrivilegeMode" direction="IN">
        <datatype type="INTEGER" minValue="0" maxValue="1"/>
      </element>
      <element name="success" direction="OUT">
        <datatype type="INTEGER" minValue="0" maxValue="1"/>
      </element>
      <element name="faultResponse" direction="OUT">
        <datatype name="XML" type="XML" contentConstraint="SEQUENCE" schemaConstraint="ANY" componentType="TYPE" componentName="XML">
          <schemaDatatype>
            <datatype name="XML" type="TREE" refId="257"></datatype>
          </schemaDatatype>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/createResource" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="resourcePath" direction="IN">
        <datatype referenceDefinitionSet="/shared/ASAssets/Utilities/TypeDefinitions" referenceType="pathType" type="STRING" maxLength="4000"/>
      </element>
      <element name="resourceName" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="resourceType" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="resourceSubType" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="success" direction="OUT">
        <datatype type="INTEGER" minValue="0" maxValue="1"/>
      </element>
      <element name="createResponse" direction="OUT">
        <datatype name="XML" type="XML" contentConstraint="SEQUENCE" schemaConstraint="ANY" componentType="TYPE" componentName="XML">
          <schemaDatatype>
            <datatype name="XML" type="TREE" refId="257"></datatype>
          </schemaDatatype>
        </datatype>
      </element>
      <element name="faultResponse" direction="OUT">
        <datatype name="XML" type="XML" contentConstraint="SEQUENCE" schemaConstraint="ANY" componentType="TYPE" componentName="XML">
          <schemaDatatype>
            <reference refId="257"/>
          </schemaDatatype>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/destroyResource" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="resourcePath" direction="IN">
        <datatype referenceDefinitionSet="/shared/ASAssets/Utilities/TypeDefinitions" referenceType="pathType" type="STRING" maxLength="4000"/>
      </element>
      <element name="resourceName" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="resourceType" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="success" direction="OUT">
        <datatype type="INTEGER" minValue="0" maxValue="1"/>
      </element>
      <element name="createResponse" direction="OUT">
        <datatype name="XML" type="XML" contentConstraint="SEQUENCE" schemaConstraint="ANY" componentType="TYPE" componentName="XML">
          <schemaDatatype>
            <datatype name="XML" type="TREE" refId="257"></datatype>
          </schemaDatatype>
        </datatype>
      </element>
      <element name="faultResponse" direction="OUT">
        <datatype name="XML" type="XML" contentConstraint="SEQUENCE" schemaConstraint="ANY" componentType="TYPE" componentName="XML">
          <schemaDatatype>
            <reference refId="257"/>
          </schemaDatatype>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/introspectResources" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="dsPath" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="catalogName" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="schemaNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="schemaTablePatterns" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="tableNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="schemaProcedurePatterns" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="procedureNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="separator" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inDebug" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="errStatus" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="errMessage" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="introspectionResult" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="dataSourceType" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="dataSourceSubtype" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/returnFolderNameAndFolderPath" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="fullResourcePath" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="mode" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="folderName" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="folderPath" direction="OUT">
        <datatype type="STRING" maxLength="4096"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/updateSqlTable" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="fullResourcePath" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="inScripttext" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="success" direction="OUT">
        <datatype type="INTEGER" minValue="0" maxValue="1"/>
      </element>
      <element name="createResponse" direction="OUT">
        <datatype name="XML" type="XML" contentConstraint="SEQUENCE" schemaConstraint="ANY" componentType="TYPE" componentName="XML">
          <schemaDatatype>
            <datatype name="XML" type="TREE" refId="257"></datatype>
          </schemaDatatype>
        </datatype>
      </element>
      <element name="faultResponse" direction="OUT">
        <datatype name="XML" type="XML" contentConstraint="SEQUENCE" schemaConstraint="ANY" componentType="TYPE" componentName="XML">
          <schemaDatatype>
            <reference refId="257"/>
          </schemaDatatype>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/CoE/MonitorServer/Customize/commonValues" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258"></datatype>
  </dependency>
  <attribute name="Script" type="STRING">/*
&#x9;MonitorServer_CreateDrop_DV_SERVER_SYSTEM_EVENT: 

&#x9;Provides a mechanism to drop/create table, alter table and drop/create indexes in the target database using native DDL.
&#x9;DV_SERVER_SYSTEM_EVENT&#x9;&#x9;- A formatting layer view that invokes the physical datasource table. 

&#x9;---------------------------------------------------------
&#x9;Generalized Syntax for SQL Server, Oracle and Postgres
&#x9;---------------------------------------------------------
&#x9;&#x9;DROP INDEX &quot;schema&quot;.&quot;DV_SERVER_SYSTEM_EVENT_IX1&quot;;
&#x9;&#x9;DROP INDEX &quot;schema&quot;.&quot;DV_SERVER_SYSTEM_EVENT_IX2&quot;;
&#x9;&#x9;DROP TABLE &quot;schema&quot;.&quot;DV_SERVER_SYSTEM_EVENT&quot;;

&#x9;&#x9;CREATE TABLE &quot;schema&quot;.&quot;DV_SERVER_SYSTEM_EVENT&quot; (
&#x9;&#x9;&#x9;...
&#x9;&#x9;);
&#x9;&#x9;CREATE INDEX &quot;DV_SERVER_SYSTEM_EVENT_IX1&quot; ON &quot;schema&quot;.&quot;DV_SERVER_SYSTEM_EVENT&quot; (...);
&#x9;&#x9;CREATE INDEX &quot;DV_SERVER_SYSTEM_EVENT_IX2&quot; ON &quot;schema&quot;.&quot;DV_SERVER_SYSTEM_EVENT&quot; (...);

&#x9;Instructions:
&#x9;&#x9;1. Modify the tableFilegroupName and indexFilegroupName if necessary.  Leave as blank &apos;&apos; if the default file group is to be used.
&#x9;&#x9;2. Add DROP INDEX and TABLE statements as necessary.
&#x9;&#x9;3. Add CREATE TABLE, ALTER TABLE and INDEX statements as necessary.
&#x9;&#x9;4. Execute the script

&#x9;Release:&#x9;Modified Date:&#x9;Modified By:&#x9;&#x9;DV Version:&#x9;&#x9;Reason:
&#x9;2020.200&#x9;05/27/2020&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.8&#x9;&#x9;&#x9;Created new.

&#x9;(c) 2017 TIBCO Software Inc.  All rights reserved.
&#x9;
&#x9;Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
&#x9;The details can be found in the file LICENSE.
&#x9;
&#x9;The following proprietary files are included as a convenience, and may not be used except pursuant
&#x9;to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
&#x9;csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
&#x9;csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
&#x9;and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
&#x9;are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
&#x9;
&#x9;This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
&#x9;If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
&#x9;agreement with TIBCO.

*/
PROCEDURE MonitorServer_CreateDrop_DV_SERVER_SYSTEM_EVENT(
&#x9;IN  destroyResources &#x9;&#x9;CHAR(1),&#x9;-- Y=destroy and recreate resources.  N=do not destroy resources.
&#x9;IN  createResources&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=create resources.  N=do not create resources.
&#x9;IN  datasourceType&#x9;&#x9;&#x9;VARCHAR,&#x9;-- Valid datasources: oracle, sqlserver, postgres
&#x9;IN  datasourcePath&#x9;&#x9;&#x9;LONGVARCHAR,-- The datasource path
&#x9;IN  catalogName&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- The name of the catalog if applicable otherwise null.
&#x9;IN  schemaName&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- The name of the schema if applicable otherwise null.
&#x9;IN  packagedQueryPath&#x9;&#x9;LONGVARCHAR,-- The path to the &quot;00_ExecuteDDL&quot; packaged query
&#x9;IN  displayDDL&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=Display the DDL, N=Do not display the DDL. 
&#x9;IN  executeDDL&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=execute the DDL for creating/dropping tables and indexes.  N=Do not execute any DDL.
&#x9;IN  dropIndexes&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=drop the indexes before creating the first.  N=do not drop the indexes.
&#x9;IN  dropTables&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=drop the tables before creating the tables.  N=do not drop the tables.
&#x9;IN  dropSequences&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=drop the sequences before creating the sequences.  N=do not drop the sequences.
&#x9;IN  createTables&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=execute the table creation DDL, N=display the table creation DDL in the console window only.
&#x9;IN  createIndexes&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=execute index creation DDL. N=display the index creation DDL in the console window only.
&#x9;IN  createSequences&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=execute sequence creation DDL. N=display the sequence creation DDL in the console window only.
&#x9;OUT result&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- PASS or FAIL.  All must pass for PASS.  If on fails then the result is FAIL.
&#x9;OUT cursCombinedResult&#x9;&#x9;LONGVARCHAR,-- Provides a status on each sql statement executed
&#x9;OUT sqlScript&#x9;&#x9;&#x9;&#x9;LONGVARCHAR&#x9;-- Generates an output of the entire script which can be used for external execution
)
BEGIN
&#x9;DECLARE moduleName&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT &apos;MonitorServer_CreateDrop_DV_SERVER_SYSTEM_EVENT&apos;;
&#x9;DECLARE ReportingPath &#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR(4000) DEFAULT /shared/CoE/MonitorServer/Customize/commonValues.ReportingPath;
&#x9;-- This is the path to the table view.
&#x9;DECLARE viewPath&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR(4000) DEFAULT REPLACE(ReportingPath||&apos;/&apos;||/shared/CoE/MonitorServer/Customize/commonValues.SystemEventTable,&apos;&quot;&apos;,&apos;&apos;);
&#x9;-- This is the tablespace/filegroup name for tables
&#x9;DECLARE tableFilegroupName &#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT /shared/CoE/MonitorServer/Customize/commonValues.tableFilegroupName;
&#x9;-- This is the tablespace/filegroup name for indexes
&#x9;DECLARE indexFilegroupName&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT /shared/CoE/MonitorServer/Customize/commonValues.indexFilegroupName;
&#x9;-- This is the table compression type
&#x9;DECLARE tableCompression&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT /shared/CoE/MonitorServer/Customize/commonValues.tableCompression;

&#x9;-- The resource container/folder which will contain the generated resources.  If the path does not exist, it will be created.
&#x9;DECLARE packagedQueryPathMod&#x9;&#x9;&#x9;LONGVARCHAR;&#x9;-- The path to the &quot;00_ExecuteDDL&quot; packaged query
&#x9;DECLARE resourceContainer&#x9;&#x9;&#x9;&#x9;VARCHAR(4000);
&#x9;DECLARE tableName&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE tablePath&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR(4000);
&#x9;DECLARE tableExists&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;BOOLEAN;
&#x9;DECLARE physicalTableExists&#x9;&#x9;&#x9;&#x9;BOOLEAN;
&#x9;DECLARE resExists&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;BOOLEAN;
&#x9;DECLARE resourcePath&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR(4000);
&#x9;DECLARE resourceName&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE scripttext&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE success&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;BIT;
&#x9;DECLARE createResponse &#x9;&#x9;&#x9;&#x9;&#x9;XML;
&#x9;DECLARE faultResponse&#x9;&#x9;&#x9;&#x9;&#x9;XML;
&#x9;-- Procedure variables. Do not modify.
&#x9;DECLARE sqlStatement&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE cursType&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE i&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE ex&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;EXCEPTION;
&#x9;DECLARE curs&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CURSOR (result INTEGER);
&#x9;DECLARE cursResult&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE status&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE TYPE sqlRowType&#x9;&#x9;&#x9;&#x9;&#x9;ROW(cursType VARCHAR, sqlStatement LONGVARCHAR);
&#x9;DECLARE sqlRow&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;sqlRowType;
&#x9;DECLARE sqlVect&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VECTOR(sqlRowType);
&#x9;DECLARE vectorCount&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;-- Variables for introspection
&#x9;DECLARE errorMessage&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE procedureNames&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE introspectionResult &#x9;&#x9;&#x9;LONGVARCHAR;&#x9;-- A line (CHR(10)) delimited string of results.  Use introspectResourcesResultCursor() to  return a cursor.
&#x9;DECLARE dataSourceType2&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;&#x9;&#x9;-- The type of data source that was introspected.
&#x9;DECLARE dataSourceSubtype2&#x9;&#x9;&#x9;&#x9;VARCHAR;&#x9;&#x9;-- The subtype of data source that was introspected.

&#x9;IF (schemaName IS NULL OR LENGTH(TRIM(schemaName)) = 0) THEN
&#x9;&#x9;RAISE ex VALUE &apos;The input parameter &quot;schemaName&quot; may not be null or empty.&apos;;
&#x9;END IF;
&#x9;-- Extract the resource container and table name
&#x9;CALL /shared/ASAssets/Utilities/repository/returnFolderNameAndFolderPath(viewPath, &apos;E&apos;, tableName, resourceContainer);
&#x9;-- Fix path with double quotes if needed
&#x9;CALL /shared/ASAssets/Utilities/repository/RepoUtils/applyReservedListToPath(packagedQueryPath, null, packagedQueryPathMod);

/************************************************************************************************
 * DROP all resources first
 ************************************************************************************************/
&#x9;IF (LOWER(datasourceType) = &apos;oracle&apos;) THEN
&#x9;&#x9;set sqlVect = VECTOR[
&#x9;&#x9;&#x9;(&apos;DROP INDEX &apos;||tableName||&apos;_IX1&apos;, &#x9;&#x9;&apos;DROP INDEX &quot;{0}&quot;.&quot;&apos;||tableName||&apos;_IX1&quot;&apos;),
&#x9;&#x9;&#x9;(&apos;DROP INDEX &apos;||tableName||&apos;_IX2&apos;, &#x9;&#x9;&apos;DROP INDEX &quot;{0}&quot;.&quot;&apos;||tableName||&apos;_IX2&quot;&apos;),
&#x9;&#x9;&#x9;(&apos;DROP TABLE &apos;||tableName, &#x9;&#x9;&#x9;&#x9;&apos;DROP TABLE &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot;&apos;)
&#x9;&#x9;];

&#x9;ELSEIF (LOWER(datasourceType) = &apos;sqlserver&apos;) THEN
&#x9;&#x9;set sqlVect = VECTOR[
&#x9;&#x9;&#x9;-- INDEXES
&#x9;&#x9;&#x9;(&apos;DROP INDEX &apos;||tableName||&apos;_IX1&apos;, &#x9;&#x9;&apos;IF EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(N&apos;&apos;&quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot;&apos;&apos;, N&apos;&apos;U&apos;&apos;) AND NAME =&apos;&apos;&apos;||tableName||&apos;_IX1&apos;&apos;)
              DROP INDEX &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot;.&quot;&apos;||tableName||&apos;_IX1&quot;&apos;),
&#x9;&#x9;&#x9;(&apos;DROP INDEX &apos;||tableName||&apos;_IX2&apos;, &#x9;&#x9;&apos;IF EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(N&apos;&apos;&quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot;&apos;&apos;, N&apos;&apos;U&apos;&apos;) AND NAME =&apos;&apos;&apos;||tableName||&apos;_IX2&apos;&apos;)
              DROP INDEX &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot;.&quot;&apos;||tableName||&apos;_IX2&quot;&apos;),
&#x9;&#x9;&#x9;-- TABLES
&#x9;&#x9;&#x9;(&apos;DROP TABLE &apos;||tableName,  &#x9;&#x9;&#x9;&apos;IF OBJECT_ID(N&apos;&apos;&quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot;&apos;&apos;, N&apos;&apos;U&apos;&apos;) IS NOT NULL DROP TABLE &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot;&apos;)
&#x9;&#x9;];
&#x9;ELSEIF (LOWER(datasourceType) = &apos;postgres&apos;) THEN
&#x9;&#x9;set sqlVect = VECTOR[
&#x9;&#x9;&#x9;(&apos;DROP INDEX &apos;||tableName||&apos;_IX1&apos;, &#x9;&#x9;&apos;DROP INDEX &quot;{0}&quot;.&quot;&apos;||tableName||&apos;_IX1&quot;&apos;),
&#x9;&#x9;&#x9;(&apos;DROP INDEX &apos;||tableName||&apos;_IX2&apos;, &#x9;&#x9;&apos;DROP INDEX &quot;{0}&quot;.&quot;&apos;||tableName||&apos;_IX2&quot;&apos;),
&#x9;&#x9;&#x9;(&apos;DROP TABLE &apos;||tableName, &#x9;&#x9;&#x9;&#x9;&apos;DROP TABLE &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot;&apos;)
&#x9;&#x9;];
&#x9;END IF;
&#x9;set vectorCount = CARDINALITY(sqlVect);

/************************************************************************************************
 * Create tables - DV_SERVER_SYSTEM_EVENT
 ************************************************************************************************/
-------------------------------------------------------------------------------------------------
-- Oracle DDL Syntax:
-------------------------------------------------------------------------------------------------
&#x9;IF (LOWER(datasourceType) = &apos;oracle&apos;) THEN
&#x9;&#x9;set sqlStatement = 
&apos;CREATE TABLE &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot; (
        &quot;PARTITION&quot;                         NUMBER(9,0),          -- The partition number which corresponds to the day of the year (1-366).
        &quot;LOAD_TIME&quot;                         TIMESTAMP(9),         -- Timestamp of when the record was inserted into the table
        &quot;NODE_HOST&quot;                         VARCHAR2(255),        -- The hostname of the server this procedure is invoked from.
        &quot;NODE_PORT&quot;                         NUMBER(9,0),          -- The port of the server this procedure is invoked from.
        &quot;TRIGGER_PATH&quot;                      VARCHAR2(4000),       -- The trigger path that was executed.
        &quot;TRIGGER_EVENT_NAME&quot;                VARCHAR2(50),         -- The trigger event name.
        &quot;TRIGGER_EVENT_TYPE&quot;                VARCHAR2(50),         -- The trigger event type.
        &quot;TRIGGER_EVENT_VALUE&quot;               VARCHAR2(4000),       -- The trigger event value.
        &quot;NODE_HOST_AFFECTED&quot;                VARCHAR2(255),        -- The hostname from the trigger event value or NODE_HOST if none.
        &quot;NODE_PORT_AFFECTED&quot;                NUMBER(9,0),          -- The port from the trigger event value or NODE_PORT if none.
        &quot;CLUSTER_NAME&quot;                      VARCHAR2(255),        -- getServerAttribute(/server/config/cluster/displayName)
        &quot;CLUSTER_IS_CLUSTER&quot;                VARCHAR2(5),          -- SYS_CLUSTER: [true|false] Is this a environment a cluster.
        &quot;CLUSTER_IS_TIMEKEEPER&quot;             VARCHAR2(5),          -- SYS_CLUSTER.TIMEKEEPER - [true|false] Is this node a timekeeper node.
        &quot;CLUSTER_STATUS&quot;                    VARCHAR2(255),        -- SYS_CLUSTER.STATUS [OPERATIONAL|DISCONNECTED] -- a single node will show OPERATIONAL.
        &quot;CLUSTER_TOTAL_TIMEKEEPER_NODES&quot;    NUMBER(9,0),          -- SYS_CLUSTER: WHERE TIMEKEEPER = &apos;&apos;Y&apos;&apos;.  Anything &gt; 1 is a problem indicating that the cluster sub-partitioned itself.
        &quot;CLUSTER_TIMEKEEPER_NODES&quot;          VARCHAR2(4000),       -- SYS_CLUSTER.SERVER_HOST||&apos;&apos;:&apos;&apos;||SERVER_PORT - comma separated list
 CONSTRAINT &quot;PK_&apos;||tableName||&apos;&quot; PRIMARY KEY 
 (
    &quot;PARTITION&quot;,
    &quot;LOAD_TIME&quot;,
    &quot;TRIGGER_EVENT_NAME&quot;,
    &quot;NODE_HOST&quot;,
    &quot;NODE_PORT&quot;
 )
) TABLESPACE &quot;{TABLE}&quot;
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
  STORAGE(BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  PARTITION BY RANGE (&quot;LOAD_TIME&quot;) INTERVAL (NUMTODSINTERVAL(1, &apos;&apos;DAY&apos;&apos;))
 (PARTITION &quot;INITIAL&quot;  VALUES LESS THAN (TIMESTAMP&apos;&apos; &apos;||CAST(CURRENT_DATE AS VARCHAR)||&apos; 00:00:00&apos;&apos;)
  SEGMENT CREATION DEFERRED
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 &apos;||TRIM(NVL(tableCompression,&apos;  &apos;))||&apos; LOGGING TABLESPACE &quot;{TABLE}&quot;
  STORAGE(BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
 )&apos;;
&#x9;set vectorCount = vectorCount + 1;
&#x9;set sqlVect = EXTEND(sqlVect, 1);
&#x9;set sqlVect[vectorCount].cursType = &apos;CREATE TABLE &apos;||tableName;
&#x9;set sqlVect[vectorCount].sqlStatement = sqlStatement;

-------------------------------------------------------------------------------------------------
-- SQL Server DDL Syntax:
-------------------------------------------------------------------------------------------------
&#x9;ELSEIF (LOWER(datasourceType) = &apos;sqlserver&apos;) THEN
&#x9;&#x9;set sqlStatement = 
&apos;CREATE TABLE &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot; (
        &quot;PARTITION&quot;                         SMALLINT NOT NULL,    -- The partition number which corresponds to the day of the year (1-366).
        &quot;LOAD_TIME&quot;                         DATETIME2(3),         -- Timestamp of when the record was inserted into the table.
        &quot;NODE_HOST&quot;                         VARCHAR(255),         -- The hostname of the server this procedure is invoked from.
        &quot;NODE_PORT&quot;                         INTEGER,              -- The port of the server this procedure is invoked from.
        &quot;TRIGGER_PATH&quot;                      VARCHAR(4000),        -- The trigger path that was executed.
        &quot;TRIGGER_EVENT_NAME&quot;                VARCHAR(50),          -- The trigger event name.
        &quot;TRIGGER_EVENT_TYPE&quot;                VARCHAR(50),          -- The trigger event type.
        &quot;TRIGGER_EVENT_VALUE&quot;               VARCHAR(4000),        -- The trigger event value.
        &quot;NODE_HOST_AFFECTED&quot;                VARCHAR(255),         -- The hostname from the trigger event value or NODE_HOST if none.
        &quot;NODE_PORT_AFFECTED&quot;                INTEGER,              -- The port from the trigger event value or NODE_PORT if none.
        &quot;CLUSTER_NAME&quot;                      VARCHAR(255),         -- getServerAttribute(/server/config/cluster/displayName)
        &quot;CLUSTER_IS_CLUSTER&quot;                VARCHAR(5),           -- SYS_CLUSTER: [true|false] Is this a environment a cluster.
        &quot;CLUSTER_IS_TIMEKEEPER&quot;             VARCHAR(5),           -- SYS_CLUSTER.TIMEKEEPER - [true|false] Is this node a timekeeper node.
        &quot;CLUSTER_STATUS&quot;                    VARCHAR(255),         -- SYS_CLUSTER.STATUS [OPERATIONAL|DISCONNECTED] -- a single node will show OPERATIONAL.
        &quot;CLUSTER_TOTAL_TIMEKEEPER_NODES&quot;    INTEGER,              -- SYS_CLUSTER: WHERE TIMEKEEPER = &apos;&apos;Y&apos;&apos;.  Anything &gt; 1 is a problem indicating that the cluster sub-partitioned itself.
        &quot;CLUSTER_TIMEKEEPER_NODES&quot;          VARCHAR(4000)         -- SYS_CLUSTER.SERVER_HOST||&apos;&apos;:&apos;&apos;||SERVER_PORT - comma separated list
 CONSTRAINT &quot;PK_&apos;||tableName||&apos;&quot; PRIMARY KEY CLUSTERED 
 (
    &quot;PARTITION&quot; ASC,
    &quot;LOAD_TIME&quot; ASC,
    &quot;TRIGGER_EVENT_NAME&quot; ASC,
    &quot;NODE_HOST&quot; ASC,
    &quot;NODE_PORT&quot;
 )
) ON &quot;CoE_ps_DayOfTheYear&quot; (&quot;PARTITION&quot;)&apos;;
&#x9;set vectorCount = vectorCount + 1;
&#x9;set sqlVect = EXTEND(sqlVect, 1);
&#x9;set sqlVect[vectorCount].cursType = &apos;CREATE TABLE &apos;||tableName;
&#x9;set sqlVect[vectorCount].sqlStatement = sqlStatement;

-------------------------------------------------------------------------------------------------
-- Postgres DDL Syntax:
-------------------------------------------------------------------------------------------------
&#x9;ELSEIF (LOWER(datasourceType) = &apos;postgres&apos;) THEN
&#x9;&#x9;set sqlStatement = 
&apos;CREATE TABLE &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot; (
        &quot;PARTITION&quot;                         DECIMAL(9,0) NOT NULL, -- The partition number which corresponds to the day of the year (1-366).
        &quot;LOAD_TIME&quot;                         TIMESTAMP,            -- Timestamp of when the record was inserted into the table.
        &quot;NODE_HOST&quot;                         VARCHAR(255),         -- The hostname of the server this procedure is invoked from.
        &quot;NODE_PORT&quot;                         INTEGER,              -- The port of the server this procedure is invoked from.
        &quot;TRIGGER_PATH&quot;                      VARCHAR(4000),        -- The trigger path that was executed.
        &quot;TRIGGER_EVENT_NAME&quot;                VARCHAR(50),          -- The trigger event name.
        &quot;TRIGGER_EVENT_TYPE&quot;                VARCHAR(50),          -- The trigger event type.
        &quot;TRIGGER_EVENT_VALUE&quot;               VARCHAR(4000),        -- The trigger event value.
        &quot;NODE_HOST_AFFECTED&quot;                VARCHAR(255),         -- The hostname from the trigger event value or NODE_HOST if none.
        &quot;NODE_PORT_AFFECTED&quot;                INTEGER,              -- The port from the trigger event value or NODE_PORT if none.
        &quot;CLUSTER_NAME&quot;                      VARCHAR(255),         -- getServerAttribute(/server/config/cluster/displayName)
        &quot;CLUSTER_IS_CLUSTER&quot;                VARCHAR(5),           -- SYS_CLUSTER: [true|false] Is this a environment a cluster.
        &quot;CLUSTER_IS_TIMEKEEPER&quot;             VARCHAR(5),           -- SYS_CLUSTER.TIMEKEEPER - [true|false] Is this node a timekeeper node.
        &quot;CLUSTER_STATUS&quot;                    VARCHAR(255),         -- SYS_CLUSTER.STATUS [OPERATIONAL|DISCONNECTED] -- a single node will show OPERATIONAL.
        &quot;CLUSTER_TOTAL_TIMEKEEPER_NODES&quot;    INTEGER,              -- SYS_CLUSTER: WHERE TIMEKEEPER = &apos;&apos;Y&apos;&apos;.  Anything &gt; 1 is a problem indicating that the cluster sub-partitioned itself.
        &quot;CLUSTER_TIMEKEEPER_NODES&quot;          VARCHAR(4000)         -- SYS_CLUSTER.SERVER_HOST||&apos;&apos;:&apos;&apos;||SERVER_PORT - comma separated list
)&apos;;
&#x9;&#x9;set vectorCount = vectorCount + 1;
&#x9;&#x9;set sqlVect = EXTEND(sqlVect, 1);
&#x9;&#x9;set sqlVect[vectorCount].cursType = &apos;CREATE TABLE &apos;||tableName;
&#x9;&#x9;set sqlVect[vectorCount].sqlStatement = sqlStatement;
&#x9;END IF;


/************************************************************************************************
 * Create indexes
 ************************************************************************************************/
&#x9;-- Indexes for DV_SERVER_SYSTEM_EVENT
&#x9;set resourceName = tableName||&apos;_IX1&apos;;
&#x9;set sqlStatement = &apos;CREATE INDEX &quot;&apos;||resourceName||&apos;&quot; ON &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot; (&quot;LOAD_TIME&quot;, &quot;NODE_HOST&quot;, &quot;NODE_PORT&quot;) ON &quot;{INDEX}&quot;&apos;;
&#x9;set vectorCount = vectorCount + 1;
&#x9;set sqlVect = EXTEND(sqlVect, 1);
&#x9;set sqlVect[vectorCount].cursType = &apos;CREATE INDEX &apos;||resourceName;
&#x9;set sqlVect[vectorCount].sqlStatement = sqlStatement;

&#x9;set resourceName = tableName||&apos;_IX2&apos;;
&#x9;set sqlStatement = &apos;CREATE INDEX &quot;&apos;||resourceName||&apos;&quot; ON &quot;{0}&quot;.&quot;&apos;||tableName||&apos;&quot; (&quot;TRIGGER_EVENT_NAME&quot;, &quot;TRIGGER_EVENT_VALUE&quot;, &quot;LOAD_TIME&quot;) ON &quot;{INDEX}&quot;&apos;;
&#x9;set vectorCount = vectorCount + 1;
&#x9;set sqlVect = EXTEND(sqlVect, 1);
&#x9;set sqlVect[vectorCount].cursType = &apos;CREATE INDEX &apos;||resourceName;
&#x9;set sqlVect[vectorCount].sqlStatement = sqlStatement;


/************************************************************************************************
 * Destroy View and Table
 ************************************************************************************************/
&#x9;-- Test for the packaged query container path
&#x9;CALL /lib/resource/ResourceExists(resourceContainer, &apos;CONTAINER&apos;, null, resExists);
&#x9;IF (NOT resExists) THEN
&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;CALL /shared/ASAssets/Utilities/repository/createAllFoldersPrivileges(resourceContainer, 1, 1, success, faultResponse);
&#x9;&#x9;END;
&#x9;END IF;

&#x9;-- Set the table path
&#x9;SET tablePath = datasourcePath;
&#x9;IF (catalogName IS NOT NULL) THEN
&#x9;&#x9;SET tablePath = tablePath||&apos;/&apos;||catalogName;
 &#x9;END IF;
&#x9;IF (schemaName IS NOT NULL) THEN
&#x9;&#x9;SET tablePath = tablePath||&apos;/&apos;||schemaName;
 &#x9;END IF;
&#x9;SET tablePath = tablePath||&apos;/&apos;||tableName;

&#x9;-- Destroy the resource if it exists and was requested to destroy
&#x9;IF (destroyResources IS NOT NULL AND UPPER(destroyResources) = &apos;Y&apos;) THEN
&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;CALL /shared/ASAssets/Utilities/repository/destroyResource(resourceContainer||&apos;/&apos;||tableName, null, &apos;TABLE&apos;, success, createResponse, faultResponse);
&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;END;
&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;CALL /shared/ASAssets/Utilities/repository/destroyResource(tablePath, null, &apos;TABLE&apos;, success, createResponse, faultResponse);
&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;END;
&#x9;END IF;

&#x9;-- Test for the deployment validate view
&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;CALL /lib/resource/ResourceExists(resourceContainer||&apos;/&apos;||tableName, &apos;TABLE&apos;, null, tableExists);
&#x9;END;

&#x9;-- Test for the physical database table
&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;CALL /lib/resource/ResourceExists(tablePath, &apos;TABLE&apos;, null, physicalTableExists);
&#x9;END;

&#x9;CALL PRINT(moduleName||&apos; : resourceContainer=[&apos;||NVL(resourceContainer,&apos;null&apos;)||&apos;]&apos;);
&#x9;CALL PRINT(moduleName||&apos; : tablePath=[&apos;||NVL(tablePath,&apos;null&apos;)||&apos;]&apos;);
&#x9;CALL PRINT(moduleName||&apos; : table view=[&apos;||NVL(resourceContainer||&apos;/&apos;||tableName,&apos;null&apos;)||&apos;] exists=[&apos;||CAST(tableExists AS VARCHAR)||&apos;]&apos;);
&#x9;CALL PRINT(moduleName||&apos; : physical table=[&apos;||NVL(tablePath,&apos;null&apos;)||&apos;] exists=[&apos;||CAST(physicalTableExists AS VARCHAR)||&apos;]&apos;);

/**********************************************************
 * Create the view &quot;DV_SERVER_SYSTEM_EVENT&quot;
 **********************************************************/
&#x9;IF (createResources IS NOT NULL AND UPPER(createResources) = &apos;Y&apos;) THEN
&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;-- Create the &quot;DV_SERVER_SYSTEM_EVENT&quot; table if it does not exist
&#x9;&#x9;&#x9;IF (NOT tableExists) THEN
&#x9;&#x9;&#x9;&#x9;CALL PRINT(moduleName||&apos; : createResource(&apos;&apos;&apos;||resourceContainer||&apos;/&apos;||tableName||&apos;&apos;&apos;, &apos;&apos;TABLE&apos;&apos;, &apos;&apos;SQL_TABLE&apos;&apos;)&apos;);
&#x9;&#x9;&#x9;&#x9;CALL /shared/ASAssets/Utilities/repository/createResource(resourceContainer, tableName, &apos;TABLE&apos;, &apos;SQL_TABLE&apos;, success, createResponse, faultResponse);
&#x9;&#x9;&#x9;&#x9;IF (faultResponse IS NOT NULL) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;RAISE ex VALUE CAST(faultResponse AS LONGVARCHAR);
&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;CALL PRINT(moduleName||&apos; : RESOURCE EXISTS(&apos;&apos;&apos;||resourceContainer||&apos;/&apos;||tableName||&apos;&apos;&apos;, &apos;&apos;TABLE&apos;&apos;, &apos;&apos;SQL_TABLE&apos;&apos;)&apos;);
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;RAISE;
&#x9;&#x9;END;
&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;-- Update the &quot;DV_SERVER_SYSTEM_EVENT&quot; table if it was newly created.
&#x9;&#x9;&#x9;IF (NOT tableExists) THEN
&#x9;&#x9;&#x9;&#x9;CALL /shared/ASAssets/Utilities/repository/RepoUtils/applyReservedListToPath(tablePath, null, resourcePath);
&#x9;&#x9;&#x9;&#x9;SET scripttext = &apos;SELECT * FROM &apos;||resourcePath||CHR(10);

&#x9;&#x9;&#x9;&#x9;CALL PRINT(moduleName||&apos; : updateSqlScript(&apos;&apos;&apos;||resourceContainer||&apos;/&apos;||tableName||&apos;&apos;&apos;)&apos;);
&#x9;&#x9;&#x9;&#x9;CALL /shared/ASAssets/Utilities/repository/updateSqlTable(resourceContainer||&apos;/&apos;||tableName, scripttext, success, createResponse, faultResponse);
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;RAISE;
&#x9;&#x9;END;
&#x9;END IF;

/***************************************************
 * PROCESS the database sqlStatements
 ***************************************************/
&#x9;IF (NOT physicalTableExists) THEN
&#x9;&#x9;CALL PRINT(moduleName||&apos; : Introspect the datasource: &apos;||datasourcePath);
&#x9;&#x9;CALL PRINT(moduleName||&apos; : Process SQL Statemenst num=&apos;||CAST(CARDINALITY(sqlVect) AS VARCHAR));
&#x9;&#x9;SET result = &apos;PASS&apos;;
&#x9;&#x9;SET sqlScript = &apos;&apos;;
&#x9;&#x9;SET i = 1;
&#x9;&#x9;WHILE (i &lt;= CARDINALITY(sqlVect)) DO
&#x9;&#x9;&#x9;SET sqlRow = sqlVect[i];

&#x9;&#x9;&#x9;-- Replace the {0} with the schemaName value
&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;{0}&apos;, schemaName);
&#x9;&#x9;&#x9;-- Check for tableFilegroupName usage
&#x9;&#x9;&#x9;if (INSTR(sqlRow.sqlStatement,&apos;{TABLE}&apos;) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;if (tableFilegroupName is not null and length(tableFilegroupName) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;if (LOWER(datasourceType) = &apos;oracle&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Replace the {TABLE} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;{TABLE}&apos;, tableFilegroupName);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;sqlserver&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Replace the {TABLE} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;{TABLE}&apos;, tableFilegroupName);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;postgres&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Replace the &quot;{TABLE}&quot; with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;{TABLE}&apos;, tableFilegroupName);
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;if (LOWER(datasourceType) = &apos;oracle&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the TABLESPACE {TABLE} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;TABLESPACE &quot;{TABLE}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;sqlserver&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the ON &quot;{TABLE}&quot; command completely
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{TABLE}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;postgres&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the TABLESPACE &quot;{TABLE}&quot; command completely
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;TABLESPACE &quot;{TABLE}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;-- Check for indexFilegroupName usage
&#x9;&#x9;&#x9;if (INSTR(sqlRow.sqlStatement,&apos;{INDEX}&apos;) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;if (indexFilegroupName is not null and length(indexFilegroupName) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;if (LOWER(datasourceType) = &apos;oracle&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Replace the {INDEX} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{INDEX}&quot;&apos;, &apos;TABLESPACE &quot;&apos;||indexFilegroupName||&apos;&quot;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;sqlserver&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Replace the {INDEX} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;{INDEX}&apos;, indexFilegroupName);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;postgres&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--  Replace the {INDEX} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{INDEX}&quot;&apos;, &apos;TABLESPACE &quot;&apos;||indexFilegroupName||&apos;&quot;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;if (LOWER(datasourceType) = &apos;oracle&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the TABLESPACE {TABLE} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{INDEX}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;sqlserver&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the ON &quot;{TABLE}&quot; command completely
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{INDEX}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;postgres&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the TABLESPACE &quot;{TABLE}&quot; command completely
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{INDEX}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;IF  (sqlRow.cursType LIKE &apos;CREATE%&apos; OR
&#x9;&#x9;&#x9;&#x9; sqlRow.cursType LIKE &apos;ALTER%&apos; OR
&#x9;&#x9;&#x9;&#x9; sqlRow.cursType LIKE &apos;EXEC%&apos; OR
&#x9;&#x9;&#x9;&#x9; sqlRow.cursType LIKE &apos;DROP%&apos; ) THEN

&#x9;&#x9;&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- If EXECUTE DDL then createTables must be = &apos;Y&apos; or dropTables must be = &apos;Y&apos; or createIndexes must be = &apos;Y&apos; or dropIndexes must be = &apos;Y&apos;.
&#x9;&#x9;&#x9;&#x9;&#x9;IF ((sqlRow.cursType LIKE &apos;CREATE TABLE%&apos;     AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;ALTER TABLE%&apos;      AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE PROCEDURE%&apos; AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE FUNCTION%&apos;  AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE PARTITION%&apos; AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE SEQUENCE%&apos;  AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE TRIGGER%&apos;   AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE INDEX%&apos;     AND createIndexes IS NOT NULL AND UPPER(createIndexes) = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP TABLE%&apos;       AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP PROCEDURE%&apos;   AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP FUNCTION%&apos;    AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP PARTITION%&apos;   AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP SEQUENCE%&apos;    AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP TRIGGER%&apos;     AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP INDEX%&apos;       AND dropIndexes   IS NOT NULL AND UPPER(dropIndexes)   = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;INSERT INTO%&apos;      AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;)) THEN

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    -- &apos;||i||&apos;:-----------------------------------------------------------------------------------------------&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (displayDDL IS NOT NULL AND UPPER(displayDDL) = &apos;Y&apos;) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Print the full SQL
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    &apos;||sqlRow.sqlStatement);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Print the short version
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    &apos;||sqlRow.cursType);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET sqlScript = sqlScript || CHR(10) || TRIM(sqlRow.sqlStatement) || &apos;;&apos; || CHR(10);

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (executeDDL IS NOT NULL and UPPER(executeDDL) = &apos;Y&apos;) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET sqlStatement = &apos;SELECT * FROM &apos;||packagedQueryPathMod||&apos;(sqlRow.sqlStatement)&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;OPEN curs FOR sqlStatement;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FETCH curs INTO cursResult;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CLOSE curs;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET status = &apos;PASS&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET status = &apos;SKIP&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET status = &apos;SKIP&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(sqlRow.cursType||&apos; EXCEPTION=&apos;||CAST(CURRENT_EXCEPTION.TRACE AS LONGVARCHAR));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursResult = -1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET status = &apos;FAIL&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Only fail the entire batch if a CREATE fails.  DOn&apos;t worry about DROP statement failing.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (INSTR(sqlRow.cursType, &apos;CREATE &apos;) &gt; 0 OR INSTR(sqlRow.cursType, &apos;ALTER &apos;) &gt; 0 OR INSTR(sqlRow.cursType, &apos;EXEC &apos;) &gt; 0) THEN 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET result = &apos;FAIL&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;END;
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;SET status = &apos;SKIP&apos;;
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;IF (cursCombinedResult IS NULL) THEN
&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = &apos;&apos;;
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult || &apos;,  &apos;||CHR(10);
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult ||status||&apos;=&apos;||sqlRow.cursType;
&#x9;&#x9;&#x9;SET i = i + 1;
&#x9;&#x9;END WHILE;


&#x9;&#x9;/*******************************************************************
&#x9;&#x9; * Introspect the datasource to bring in the table
&#x9;&#x9; *******************************************************************/
&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;IF (UPPER(executeDDL) = &apos;Y&apos; AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) THEN
&#x9;&#x9;&#x9;&#x9;IF (status &lt;&gt; &apos;FAIL&apos;) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    -- &apos;||i||&apos;:-----------------------------------------------------------------------------------------------&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    Introspect the datasource table [&apos;||tableName||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;CALL /shared/ASAssets/Utilities/repository/introspectResources(
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;datasourcePath, catalogName, schemaName, null, tableName, null, null, &apos;,&apos;, &apos;N&apos;,
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;status, errorMessage, introspectionResult, dataSourceType2, dataSourceSubtype2);
&#x9;&#x9;&#x9;&#x9;&#x9;IF (status = &apos;FAILED&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;RAISE ex VALUE errorMessage;
&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    -- &apos;||i||&apos;:-----------------------------------------------------------------------------------------------&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    Unable to Introspect the datasource table [&apos;||tableName||&apos;] due to previous failure.&apos;);
&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;SET i = i + 1;
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;END;
&#x9;ELSE
&#x9;&#x9;CALL PRINT(moduleName||&apos; : RESOURCE EXISTS(&apos;&apos;&apos;||tablePath||&apos;&apos;&apos;, &apos;&apos;TABLE&apos;&apos;, &apos;&apos;SQL_TABLE&apos;&apos;)&apos;);
&#x9;END IF;

&#x9;CALL PRINT(&apos;&apos;);
END</attribute>
  <attribute name="creationDate" type="LONG">1410976495807</attribute>
  <attribute name="creatorUserDomain" type="STRING">ldap</attribute>
  <attribute name="creatorUserName" type="STRING">zkxl6un</attribute>
  <attribute name="explicitly.designed" type="BOOLEAN">false</attribute>
  <attribute name="lastModifiedDate" type="LONG">1601333668980</attribute>
  <attribute name="lastModifiedUserDomain" type="STRING">composite</attribute>
  <attribute name="lastModifiedUserName" type="STRING">admin</attribute>
  <attribute name="model" type="NULL"/>
  <attribute name="native_only" type="STRING">false</attribute>
  <attribute name="references" type="MAP">
    <item>
      <key type="STRING">13/462</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">7/326</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/508</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">13/459</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">12/480</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/517</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/507</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/516</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/338</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">12/456</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/369</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/523</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/344</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">7/328</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/356</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">7/526</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">7/327</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/370</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">7/329</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
  </attribute>
</metadata>