<?xml version="1.1" encoding="UTF-8"?>
<!-- salt:4eac6a34-df40-4265-b123-32a6ac34cac2 -->
<metadata name="MonitorServer_CreateDrop_DB_Functions" path="/shared/CoE/MonitorServer/Datasources/InitializeTable/CreateDropTables/MonitorServer_CreateDrop_DB_Functions" type="PROCEDURE" subtype="SQL_SCRIPT_PROCEDURE" changeToken="0">
  <annotation><![CDATA[
&#x9;(c) 2017 TIBCO Software Inc.  All rights reserved.
&#x9;
&#x9;Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
&#x9;The details can be found in the file LICENSE.
&#x9;
&#x9;The following proprietary files are included as a convenience, and may not be used except pursuant
&#x9;to valid license to Composite Information Server or TIBCOÂ® Data Virtualization Server:
&#x9;csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
&#x9;csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
&#x9;and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
&#x9;are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
&#x9;
&#x9;This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
&#x9;If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
&#x9;agreement with TIBCO.

]]></annotation>
  <parameters>
    <parameter name="destroyResources" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="createResources" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="datasourceType" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="datasourcePath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="catalogName" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="schemaName" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="packagedQueryPath" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="displayDDL" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="executeDDL" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="dropIndexes" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="dropTables" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="dropSequences" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="createTables" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="createIndexes" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="createSequences" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="result" direction="OUT" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="cursCombinedResult" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="sqlScript" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
  </parameters>
  <security>
    <owner user="admin" domain="composite"/>
  </security>
  <dependency target="/lib/debug/Print" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="textToPrint" direction="IN">
        <datatype referenceDefinitionSet="/lib/util/System" referenceType="Text" type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/lib/resource/ResourceExists" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="path" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourcePath" type="STRING" maxLength="4096"/>
      </element>
      <element name="type" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourceType" type="STRING" maxLength="40"/>
      </element>
      <element name="version" direction="IN">
        <datatype referenceDefinitionSet="/lib/resource/ResourceDefs" referenceType="ResourceVersion" type="STRING" maxLength="255"/>
      </element>
      <element name="exists" direction="OUT">
        <datatype type="BOOLEAN"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/RepoUtils/applyReservedListToPath" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="inPath" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="debug" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/destroyResource" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="resourcePath" direction="IN">
        <datatype referenceDefinitionSet="/shared/ASAssets/Utilities/TypeDefinitions" referenceType="pathType" type="STRING" maxLength="4000"/>
      </element>
      <element name="resourceName" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="resourceType" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="success" direction="OUT">
        <datatype type="INTEGER" minValue="0" maxValue="1"/>
      </element>
      <element name="createResponse" direction="OUT">
        <datatype name="XML" type="XML" contentConstraint="SEQUENCE" schemaConstraint="ANY" componentType="TYPE" componentName="XML">
          <schemaDatatype>
            <datatype name="XML" type="TREE" refId="257"></datatype>
          </schemaDatatype>
        </datatype>
      </element>
      <element name="faultResponse" direction="OUT">
        <datatype name="XML" type="XML" contentConstraint="SEQUENCE" schemaConstraint="ANY" componentType="TYPE" componentName="XML">
          <schemaDatatype>
            <reference refId="257"/>
          </schemaDatatype>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/getBasicResourceCursor_PROCEDURE_CURSOR" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="fullResourcePath" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="resourceType" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="cursorNum" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="TABLE" refId="256">
          <element name="resourceId">
            <datatype type="INTEGER"/>
          </element>
          <element name="resourceName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="resourcePath">
            <datatype type="STRING" maxLength="4096"/>
          </element>
          <element name="resourceType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="subtype">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="changeId">
            <datatype type="INTEGER"/>
          </element>
          <element name="ownerName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="ownerDomain">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="impactLevel">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="enabled">
            <datatype type="INTEGER" minValue="0" maxValue="1"/>
          </element>
          <element name="annotation">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="explicitlyDesigned">
            <datatype type="INTEGER" minValue="0" maxValue="1"/>
          </element>
          <element name="tableType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="sqlText">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="proprietaryModel">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
          <element name="columnNum">
            <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
          </element>
          <element name="columnName">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="columnType">
            <datatype type="STRING" maxLength="4096"/>
          </element>
          <element name="columnBaseType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="dataType">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="paramDirection">
            <datatype type="STRING" maxLength="255"/>
          </element>
          <element name="nativeBaseType">
            <datatype type="STRING" maxLength="32768"/>
          </element>
          <element name="nativeType">
            <datatype type="STRING" maxLength="32768"/>
          </element>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/repository/introspectResources" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="dsPath" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="catalogName" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="schemaNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="schemaTablePatterns" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="tableNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="schemaProcedurePatterns" direction="IN">
        <datatype type="STRING" maxLength="4096"/>
      </element>
      <element name="procedureNames" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="separator" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inDebug" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="errStatus" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="errMessage" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="introspectionResult" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="dataSourceType" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="dataSourceSubtype" direction="OUT">
        <datatype type="STRING" maxLength="255"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/ASAssets/Utilities/string/extractDelimitedText" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="inputString" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="delimiter" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="occurrence" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="reverseInputText" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="reverseOutput" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="trimText" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="includeDelimiter" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="TABLE" refId="256">
          <element name="object">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/CoE/MonitorServer/Customize/commonValues" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258"></datatype>
  </dependency>
  <attribute name="Script" type="STRING">/*
&#x9;MonitorServer_CreateDrop_DB_Functions: 

&#x9;Provides a mechanism to drop/create database functions and partitioning schemes.

&#x9;Release:&#x9;Modified Date:&#x9;Modified By:&#x9;&#x9;DV Version:&#x9;&#x9;Reason:
&#x9;2020.200&#x9;05/27/2020&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.8&#x9;&#x9;&#x9;Created new.

&#x9;(c) 2017 TIBCO Software Inc.  All rights reserved.
&#x9;
&#x9;Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
&#x9;The details can be found in the file LICENSE.
&#x9;
&#x9;The following proprietary files are included as a convenience, and may not be used except pursuant
&#x9;to valid license to Composite Information Server or TIBCOÂ® Data Virtualization Server:
&#x9;csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
&#x9;csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
&#x9;and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
&#x9;are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
&#x9;
&#x9;This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
&#x9;If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
&#x9;agreement with TIBCO.

*/
PROCEDURE MonitorServer_CreateDrop_DB_Functions(
&#x9;IN  destroyResources &#x9;&#x9;CHAR(1),&#x9;-- Y=destroy and recreate resources.  N=do not destroy resources.
&#x9;IN  createResources&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=create resources.  N=do not create resources.
&#x9;IN  datasourceType&#x9;&#x9;&#x9;VARCHAR,&#x9;-- Valid datasources: oracle, sqlserver, postgres
&#x9;IN  datasourcePath&#x9;&#x9;&#x9;LONGVARCHAR,-- The datasource path
&#x9;IN  catalogName&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- The name of the catalog if applicable otherwise null.
&#x9;IN  schemaName&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- The name of the schema if applicable otherwise null.
&#x9;IN  packagedQueryPath&#x9;&#x9;LONGVARCHAR,-- The path to the &quot;00_ExecuteDDL&quot; packaged query
&#x9;IN  displayDDL&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=Display the DDL, N=Do not display the DDL. 
&#x9;IN  executeDDL&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=execute the DDL for creating/dropping tables and indexes.  N=Do not execute any DDL.
&#x9;IN  dropIndexes&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=drop the indexes before creating the first.  N=do not drop the indexes.
&#x9;IN  dropTables&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=drop the tables before creating the tables.  N=do not drop the tables.
&#x9;IN  dropSequences&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=drop the sequences before creating the sequences.  N=do not drop the sequences.
&#x9;IN  createTables&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=execute the table creation DDL, N=display the table creation DDL in the console window only.
&#x9;IN  createIndexes&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=execute index creation DDL. N=display the index creation DDL in the console window only.
&#x9;IN  createSequences&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Y=execute sequence creation DDL. N=display the sequence creation DDL in the console window only.
&#x9;OUT result&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- PASS or FAIL.  All must pass for PASS.  If on fails then the result is FAIL.
&#x9;OUT cursCombinedResult&#x9;&#x9;LONGVARCHAR,-- Provides a status on each sql statement executed
&#x9;OUT sqlScript&#x9;&#x9;&#x9;&#x9;LONGVARCHAR&#x9;-- Generates an output of the entire script which can be used for external execution
)
BEGIN
&#x9;DECLARE moduleName&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT &apos;MonitorServer_CreateDrop_DB_Functions&apos;;
&#x9;-- This is the tablespace/filegroup name for tables
&#x9;DECLARE tableFilegroupName &#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT /shared/CoE/MonitorServer/Customize/commonValues.tableFilegroupName;
&#x9;-- This is the tablespace/filegroup name for indexes
&#x9;DECLARE indexFilegroupName&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT /shared/CoE/MonitorServer/Customize/commonValues.indexFilegroupName;

&#x9;-- The resource container/folder which will contain the generated resources.  If the path does not exist, it will be created.
&#x9;DECLARE packagedQueryPathMod&#x9;&#x9;&#x9;LONGVARCHAR;&#x9;-- The path to the &quot;00_ExecuteDDL&quot; packaged query
&#x9;DECLARE resourceName&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;-- Procedure variables. Do not modify.
&#x9;DECLARE sqlStatement&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE cursType&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE i&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE ex&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;EXCEPTION;
&#x9;DECLARE curs&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CURSOR (result INTEGER);
&#x9;DECLARE cursResult&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE status&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
    DECLARE TYPE sqlRowType&#x9;&#x9;&#x9;&#x9;&#x9;ROW(cursType VARCHAR, sqlStatement LONGVARCHAR, validation LONGVARCHAR);
&#x9;DECLARE sqlRow&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;sqlRowType;
&#x9;DECLARE sqlVect&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VECTOR(sqlRowType);
&#x9;DECLARE vectorCount&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;-- Variables to clean-up procedures
&#x9;DECLARE resExists&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;BOOLEAN;
&#x9;DECLARE success&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE createResponse&#x9;&#x9;&#x9;&#x9;&#x9;XML;
&#x9;DECLARE faultResponse&#x9;&#x9;&#x9;&#x9;&#x9;XML;
&#x9;DECLARE pos1, pos2, len&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;-- Variables for validation
&#x9;DECLARE dataSourceSchemaPath&#x9;&#x9;&#x9;VARCHAR(4000);
&#x9;DECLARE resourcePath&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR(4000);
&#x9;DECLARE columnCount&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE columnMax&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE columnMissingList&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;-- Variables for introspection
&#x9;DECLARE errorMessage&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE procedureNames&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE introspectionResult &#x9;&#x9;&#x9;LONGVARCHAR;&#x9;-- A line (CHR(10)) delimited string of results.  Use introspectResourcesResultCursor() to  return a cursor.
&#x9;DECLARE dataSourceType2&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;&#x9;&#x9;-- The type of data source that was introspected.
&#x9;DECLARE dataSourceSubtype2&#x9;&#x9;&#x9;&#x9;VARCHAR;&#x9;&#x9;-- The subtype of data source that was introspected.

&#x9;IF (schemaName IS NULL OR LENGTH(TRIM(schemaName)) = 0) THEN
&#x9;&#x9;RAISE ex VALUE &apos;The input parameter &quot;schemaName&quot; may not be null or empty.&apos;;
&#x9;END IF;
&#x9;-- Fix path with double quotes if needed
&#x9;CALL /shared/ASAssets/Utilities/repository/RepoUtils/applyReservedListToPath(packagedQueryPath, null, packagedQueryPathMod);
&#x9;-- Set the data source schema path
&#x9;SET dataSourceSchemaPath = datasourcePath;
&#x9;IF (catalogName IS NOT NULL AND LENGTH(TRIM(catalogName)) &gt; 0) THEN
&#x9;&#x9;SET dataSourceSchemaPath = dataSourceSchemaPath || &apos;/&apos; || catalogName;
&#x9;END IF;
&#x9;IF (schemaName IS NOT NULL AND LENGTH(TRIM(schemaName)) &gt; 0) THEN
&#x9;&#x9;SET dataSourceSchemaPath = dataSourceSchemaPath || &apos;/&apos; || schemaName;
&#x9;END IF;

/************************************************************************************************
 * DROP all resources first
 ************************************************************************************************/
&#x9;IF (LOWER(datasourceType) = &apos;oracle&apos;) THEN
&#x9;&#x9;set sqlVect = VECTOR[
&#x9;&#x9;&#x9;-- FUNCTIONS and SCHEMES
&#x9;&#x9;&#x9;-- Note: The third column is used to validate the procedure or function parameters after they are introspected.
&#x9;&#x9;&#x9;(&apos;DROP FUNCTION F_GET_PARTITION_NUM_COE&apos;,&#x9;&#x9;&#x9;&apos;DROP FUNCTION &quot;{0}&quot;.&quot;F_GET_PARTITION_NUM_COE&quot;&apos;,&apos;INDATE|&apos;)
&#x9;&#x9;];
&#x9;&#x9;-- Used for introspection
&#x9;&#x9;SET procedureNames = &apos;F_GET_PARTITION_NUM_COE&apos;;

&#x9;ELSEIF (LOWER(datasourceType) = &apos;sqlserver&apos;) THEN
&#x9;&#x9;set sqlVect = VECTOR[
&#x9;&#x9;&#x9;-- FUNCTIONS and SCHEMES
&#x9;&#x9;&#x9;-- Note: The third column is used to validate the procedure or function parameters after they are introspected.
&#x9;&#x9;&#x9;(&apos;DROP FUNCTION F_GET_PARTITION_NUM_COE&apos;,&#x9;&#x9;&#x9;&apos;IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N&apos;&apos;&quot;{0}&quot;.&quot;F_GET_PARTITION_NUM_COE&quot;&apos;&apos;) AND type in (N&apos;&apos;FN&apos;&apos;, N&apos;&apos;IF&apos;&apos;,N&apos;&apos;TF&apos;&apos;, N&apos;&apos;FS&apos;&apos;, N&apos;&apos;FT&apos;&apos;)) DROP FUNCTION &quot;{0}&quot;.&quot;F_GET_PARTITION_NUM_COE&quot;&apos;,&apos;@inDate|&apos;),
&#x9;&#x9;&#x9;(&apos;DROP PARTITION SCHEME CoE_ps_DayOfTheYear&apos;,&#x9;&#x9;&apos;IF EXISTS (SELECT name FROM sys.PARTITION_SCHEMES WHERE name = &apos;&apos;CoE_ps_DayOfTheYear&apos;&apos;) DROP PARTITION SCHEME &quot;CoE_ps_DayOfTheYear&quot;&apos;,null),
&#x9;&#x9;&#x9;(&apos;DROP PARTITION FUNCTION CoE_pf_DayOfTheYear&apos;,&#x9;&#x9;&apos;IF EXISTS (SELECT name FROM SYS.PARTITION_FUNCTIONS WHERE name = &apos;&apos;CoE_pf_DayOfTheYear&apos;&apos;) DROP PARTITION FUNCTION &quot;CoE_pf_DayOfTheYear&quot;&apos;,null)
&#x9;&#x9;];
&#x9;&#x9;-- Used for introspection
&#x9;&#x9;SET procedureNames = &apos;F_GET_PARTITION_NUM_COE&apos;;

&#x9;ELSEIF (LOWER(datasourceType) = &apos;postgres&apos;) THEN
&#x9;&#x9;set sqlVect = VECTOR[
&#x9;&#x9;];
&#x9;&#x9;-- Used for introspection
&#x9;&#x9;SET procedureNames = null;
&#x9;END IF;
&#x9;set vectorCount = CARDINALITY(sqlVect);

/************************************************************************************************
 * CREATE metadata partition functions and schemes
 ************************************************************************************************/

-------------------------------------------------------------------------------------------------
-- Oracle DDL Syntax:
-------------------------------------------------------------------------------------------------
IF (LOWER(datasourceType) = &apos;oracle&apos;) THEN
&#x9;-------------------------------------------------------------------------------------------------
&#x9;-- CREATE metadata partition functions and schemes
&#x9;-------------------------------------------------------------------------------------------------
&#x9;set resourceName = &apos;F_GET_PARTITION_NUM_COE&apos;;
&#x9;set sqlStatement = 
&apos;CREATE OR REPLACE FUNCTION &quot;{0}&quot;.&quot;&apos;||resourceName||&apos;&quot; (inDate IN DATE)
   RETURN NUMBER AS 
   partition_num   NUMBER(9,0);
   DayOfTheYear    NUMBER(9,0);
   AddOneDay       NUMBER(9,0);
   BEGIN 
      DayOfTheYear := TO_CHAR(inDate, &apos;&apos;DDD&apos;&apos;);
      -- Determine if this is leap year or not.  If not then add one to the &quot;day of the year&quot;
      IF TO_CHAR(LAST_DAY(TO_DATE(&apos;&apos;01/02/&apos;&apos;||TO_CHAR(inDate, &apos;&apos;YYYY&apos;&apos;), &apos;&apos;dd/mm/yyyy&apos;&apos;)), &apos;&apos;DD&apos;&apos;) = 29 THEN
         AddOneDay := 0;
      ELSE
         AddOneDay := 1;
      END IF;
     partition_num := DayOfTheYear + AddOneDay;
     return partition_num;
END;&apos;;
&#x9;set vectorCount = vectorCount + 1;
&#x9;set sqlVect = EXTEND(sqlVect, 1);
&#x9;set sqlVect[vectorCount].cursType = &apos;CREATE FUNCTION &apos;||resourceName;
&#x9;set sqlVect[vectorCount].sqlStatement = sqlStatement;

-------------------------------------------------------------------------------------------------
-- SQL Server DDL Syntax:
-------------------------------------------------------------------------------------------------
ELSEIF (LOWER(datasourceType) = &apos;sqlserver&apos;) THEN
&#x9;-------------------------------------------------------------------------------------------------
&#x9;-- CREATE metadata partition functions and schemes
&#x9;-------------------------------------------------------------------------------------------------
&#x9;set resourceName = &apos;F_GET_PARTITION_NUM_COE&apos;;
&#x9;set sqlStatement = 
&apos;CREATE FUNCTION &quot;{0}&quot;.&quot;&apos;||resourceName||&apos;&quot; (@inDate date = NULL)
RETURNS SMALLINT AS
BEGIN
DECLARE @doty SMALLINT
DECLARE @isLeapYr SMALLINT
DECLARE @AddOneDay SMALLINT = 0
DECLARE @compareDt DATETIME2

SELECT @isLeapYr = case datepart(mm, dateadd(dd, 1, cast((cast(DATEPART(year, @inDate) as varchar(4)) + &apos;&apos;0228&apos;&apos;) as date))) when 2 then 1 else 0 end;
IF (@isLeapYr = 0)
&#x9;BEGIN
&#x9;&#x9;SET @compareDt = cast((cast(DATEPART(year, @inDate) as varchar(4)) + &apos;&apos;0228&apos;&apos;) as date);
&#x9;&#x9;IF (@inDate &gt; @compareDt)
&#x9;&#x9;BEGIN
&#x9;&#x9;&#x9;SET @AddOneDay = 1;
&#x9;&#x9;END
&#x9;END

IF (@inDate IS NULL)
    BEGIN
        SELECT @doty = DATEPART(dy, GETUTCDATE()) + @AddOneDay;
    END
ELSE
    BEGIN
       SELECT @doty = DATEPART(dy, @inDate) + @AddOneDay;
    END
RETURN @doty
END&apos;;
&#x9;set vectorCount = vectorCount + 1;
&#x9;set sqlVect = EXTEND(sqlVect, 1);
&#x9;set sqlVect[vectorCount].cursType = &apos;CREATE FUNCTION &apos;||resourceName;
&#x9;set sqlVect[vectorCount].sqlStatement = sqlStatement;


&#x9;set resourceName = &apos;CoE_pf_DayOfTheYear&apos;;
&#x9;set sqlStatement = 
&apos;CREATE PARTITION FUNCTION &quot;&apos;||resourceName||&apos;&quot;(SMALLINT) AS RANGE LEFT FOR VALUES (
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 
    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 
    61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 
    91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 
    121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 
    151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 
    181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 
    211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 
    241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 
    271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 
    301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 
    331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 
    361, 362, 363, 364, 365, 366)&apos;;
&#x9;set vectorCount = vectorCount + 1;
&#x9;set sqlVect = EXTEND(sqlVect, 1);
&#x9;set sqlVect[vectorCount].cursType = &apos;CREATE PARTITION FUNCTION &apos;||resourceName;
&#x9;set sqlVect[vectorCount].sqlStatement = sqlStatement;

&#x9;set resourceName = &apos;CoE_ps_DayOfTheYear&apos;;
&#x9;-- Check for tableFilegroupName usage
&#x9;if (tableFilegroupName is not null and length(tableFilegroupName) &gt; 0) then
&#x9;&#x9;set sqlStatement = &apos;CREATE PARTITION SCHEME &quot;&apos;||resourceName||&apos;&quot; AS PARTITION &quot;CoE_pf_DayOfTheYear&quot; ALL TO (&quot;&apos;||tableFilegroupName||&apos;&quot;)&apos;;
&#x9;else
&#x9;&#x9;set sqlStatement = &apos;CREATE PARTITION SCHEME &quot;&apos;||resourceName||&apos;&quot; AS PARTITION &quot;CoE_pf_DayOfTheYear&quot; ALL TO ([PRIMARY])&apos;;
&#x9;end if;
&#x9;set vectorCount = vectorCount + 1;
&#x9;set sqlVect = EXTEND(sqlVect, 1);
&#x9;set sqlVect[vectorCount].cursType = &apos;CREATE PARTITION SCHEME &apos;||resourceName;
&#x9;set sqlVect[vectorCount].sqlStatement = sqlStatement;

-------------------------------------------------------------------------------------------------
-- Postgres DDL Syntax:
-------------------------------------------------------------------------------------------------
ELSEIF (LOWER(datasourceType) = &apos;postgres&apos;) THEN
&#x9;-------------------------------------------------------------------------------------------------
&#x9;-- CREATE metadata partition functions and schemes
&#x9;-------------------------------------------------------------------------------------------------

END IF;


/***************************************************
 * PROCESS the database sqlStatements
 ***************************************************/
&#x9;&#x9;CALL PRINT(moduleName||&apos; : Introspect the datasource: &apos;||NVL(datasourcePath,&apos;null&apos;));
&#x9;&#x9;CALL PRINT(moduleName||&apos; : Process SQL Statements num=&apos;||CAST(CARDINALITY(sqlVect) AS VARCHAR));
&#x9;&#x9;SET result = &apos;PASS&apos;;
&#x9;&#x9;SET sqlScript = &apos;&apos;;
&#x9;&#x9;SET i = 1;
&#x9;&#x9;WHILE (i &lt;= CARDINALITY(sqlVect)) DO
&#x9;&#x9;&#x9;SET sqlRow = sqlVect[i];

&#x9;&#x9;&#x9;-- Replace the {0} with the schemaName value
&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;{0}&apos;, schemaName);
&#x9;&#x9;&#x9;-- Check for tableFilegroupName usage
&#x9;&#x9;&#x9;if (INSTR(sqlRow.sqlStatement,&apos;{TABLE}&apos;) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;if (tableFilegroupName is not null and length(tableFilegroupName) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;if (LOWER(datasourceType) = &apos;oracle&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Replace the {TABLE} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{TABLE}&quot;&apos;, &apos;TABLESPACE &quot;&apos;||tableFilegroupName||&apos;&quot;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;sqlserver&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Replace the {TABLE} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;{TABLE}&apos;, tableFilegroupName);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;postgres&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the ON &quot;{TABLE}&quot; command completely
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{TABLE}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the ON &quot;{TABLE}&quot; command completely
&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{TABLE}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;-- Check for indexFilegroupName usage
&#x9;&#x9;&#x9;if (INSTR(sqlRow.sqlStatement,&apos;{INDEX}&apos;) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;if (indexFilegroupName is not null and length(indexFilegroupName) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;if (LOWER(datasourceType) = &apos;oracle&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Replace the {INDEX} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{INDEX}&quot;&apos;, &apos;TABLESPACE &quot;&apos;||indexFilegroupName||&apos;&quot;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;sqlserver&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Replace the {INDEX} with the tableFilegroupName value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;{INDEX}&apos;, indexFilegroupName);
&#x9;&#x9;&#x9;&#x9;&#x9;elseif (LOWER(datasourceType) = &apos;postgres&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the ON &quot;{INDEX}&quot; command completely
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{INDEX}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the ON &quot;{INDEX}&quot; command completely
&#x9;&#x9;&#x9;&#x9;&#x9;set sqlRow.sqlStatement = REPLACE(sqlRow.sqlStatement, &apos;ON &quot;{INDEX}&quot;&apos;, &apos;&apos;);
&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;IF  (sqlRow.cursType LIKE &apos;CREATE%&apos; OR
&#x9;&#x9;&#x9;&#x9; sqlRow.cursType LIKE &apos;ALTER%&apos; OR
&#x9;&#x9;&#x9;&#x9; sqlRow.cursType LIKE &apos;EXEC%&apos; OR
&#x9;&#x9;&#x9;&#x9; sqlRow.cursType LIKE &apos;DROP%&apos; ) THEN

&#x9;&#x9;&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- If EXECUTE DDL then createTables must be = &apos;Y&apos; or dropTables must be = &apos;Y&apos; or createIndexes must be = &apos;Y&apos; or dropIndexes must be = &apos;Y&apos;.
&#x9;&#x9;&#x9;&#x9;&#x9;IF ((sqlRow.cursType LIKE &apos;CREATE TABLE%&apos;     AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;ALTER TABLE%&apos;      AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE PROCEDURE%&apos; AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE FUNCTION%&apos;  AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE PARTITION%&apos; AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE SEQUENCE%&apos;  AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE TRIGGER%&apos;   AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;CREATE INDEX%&apos;     AND createIndexes IS NOT NULL AND UPPER(createIndexes) = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP TABLE%&apos;       AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP PROCEDURE%&apos;   AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP FUNCTION%&apos;    AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP PARTITION%&apos;   AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP SEQUENCE%&apos;    AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP TRIGGER%&apos;     AND dropTables    IS NOT NULL AND UPPER(dropTables)    = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;DROP INDEX%&apos;       AND dropIndexes   IS NOT NULL AND UPPER(dropIndexes)   = &apos;Y&apos;) OR
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(sqlRow.cursType LIKE &apos;INSERT INTO%&apos;      AND createTables  IS NOT NULL AND UPPER(createTables)  = &apos;Y&apos;)) THEN

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    -- &apos;||i||&apos;:-----------------------------------------------------------------------------------------------&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (displayDDL IS NOT NULL AND UPPER(displayDDL) = &apos;Y&apos;) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Print the full SQL
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    &apos;||sqlRow.sqlStatement);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Print the short version
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    &apos;||sqlRow.cursType);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET sqlScript = sqlScript || CHR(10) || TRIM(sqlRow.sqlStatement) || &apos;;&apos; || CHR(10);

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (executeDDL IS NOT NULL and UPPER(executeDDL) = &apos;Y&apos;) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET sqlStatement = &apos;SELECT * FROM &apos;||packagedQueryPathMod||&apos;(sqlRow.sqlStatement)&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;OPEN curs FOR sqlStatement;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FETCH curs INTO cursResult;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CLOSE curs;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET status = &apos;PASS&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET status = &apos;SKIP&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET status = &apos;SKIP&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(sqlRow.cursType||&apos; EXCEPTION=&apos;||CAST(CURRENT_EXCEPTION.TRACE AS LONGVARCHAR));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursResult = -1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET status = &apos;FAIL&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Only fail the entire batch if a CREATE fails.  DOn&apos;t worry about DROP statement failing.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (INSTR(sqlRow.cursType, &apos;CREATE &apos;) &gt; 0 OR INSTR(sqlRow.cursType, &apos;ALTER &apos;) &gt; 0 OR INSTR(sqlRow.cursType, &apos;EXEC &apos;) &gt; 0) THEN 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET result = &apos;FAIL&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;END;
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;SET status = &apos;SKIP&apos;;
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;IF (cursCombinedResult IS NULL) THEN
&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = &apos;&apos;;
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult || &apos;,  &apos;||CHR(10);
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult ||status||&apos;=&apos;||sqlRow.cursType;
&#x9;&#x9;&#x9;SET i = i + 1;
&#x9;&#x9;END WHILE;


&#x9;&#x9;/*******************************************************************
&#x9;&#x9; * Destory the datasource procedures
&#x9;&#x9; *******************************************************************/
&#x9;&#x9;IF (UPPER(executeDDL) = &apos;Y&apos; AND UPPER(destroyResources) = &apos;Y&apos; AND procedureNames IS NOT NULL) THEN
&#x9;&#x9;&#x9;SET procedureNames = procedureNames || &apos;,&apos;;
&#x9;&#x9;&#x9;-- Test for the resource
&#x9;&#x9;&#x9;SET pos1 = 1;
&#x9;&#x9;&#x9;SET pos2 = INSTR(procedureNames, &apos;,&apos;);
&#x9;&#x9;&#x9;WHILE (pos2 &gt; 0) DO
&#x9;&#x9;&#x9;&#x9;SET resourceName = SUBSTRING(procedureNames, pos1, pos2-pos1);
&#x9;&#x9;&#x9;&#x9;IF (LENGTH(TRIM(resourceName)) &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    -- &apos;||i||&apos;:-----------------------------------------------------------------------------------------------&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    Destory the CoE datasource procedure [&apos;||resourceName||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;set i = i + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;SET resourcePath = dataSourceSchemaPath || &apos;/&apos; || resourceName;
&#x9;&#x9;&#x9;&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL /lib/resource/ResourceExists(resourcePath, &apos;PROCEDURE&apos;, null, resExists);
&#x9;&#x9;&#x9;&#x9;&#x9;END;
&#x9;&#x9;&#x9;&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (resExists) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL /shared/ASAssets/Utilities/repository/destroyResource(resourcePath, null, &apos;PROCEDURE&apos;, success, createResponse, faultResponse);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;END;
&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;SET pos1 = pos2+1;
&#x9;&#x9;&#x9;&#x9;SET pos2 = INSTR(procedureNames, &apos;,&apos;,pos1);
&#x9;&#x9;&#x9;END WHILE;
&#x9;&#x9;END IF;

&#x9;&#x9;/*******************************************************************
&#x9;&#x9; * Introspect the datasource to bring in the procedures
&#x9;&#x9; *******************************************************************/
&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;IF (UPPER(executeDDL) = &apos;Y&apos; AND UPPER(createResources) = &apos;Y&apos; AND procedureNames IS NOT NULL) THEN
&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    -- &apos;||i||&apos;:-----------------------------------------------------------------------------------------------&apos;);
&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;    Introspect the CoE datasource procedures [&apos;||procedureNames||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;CALL /shared/ASAssets/Utilities/repository/introspectResources(
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;datasourcePath, catalogName, schemaName, null, null, null, procedureNames, &apos;,&apos;, &apos;N&apos;,
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;status, errorMessage, introspectionResult, dataSourceType2, dataSourceSubtype2);
&#x9;&#x9;&#x9;&#x9;IF (status = &apos;FAILED&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;RAISE ex VALUE errorMessage;
&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;SET i = i + 1;
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;END;

&#x9;&#x9;/*******************************************************************
&#x9;&#x9; * Validate the columns for the procedure
&#x9;&#x9; *******************************************************************/
&#x9;&#x9;IF (UPPER(executeDDL) = &apos;Y&apos; AND UPPER(createResources) = &apos;Y&apos; AND procedureNames IS NOT NULL) THEN
&#x9;&#x9;&#x9;CALL PRINT(&apos;    -- &apos;||i||&apos;:-----------------------------------------------------------------------------------------------&apos;);
&#x9;&#x9;&#x9;CALL PRINT(&apos;    Validate Procedure Columns:&apos;);
&#x9;&#x9;&#x9;SET i = 1;
&#x9;&#x9;&#x9;WHILE (i &lt;= CARDINALITY(sqlVect)) DO
&#x9;&#x9;&#x9;&#x9;SET sqlRow = sqlVect[i];
&#x9;&#x9;&#x9;&#x9;IF (sqlRow.validation IS NOT NULL) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;-- Determine the maximum number of columns in the list
&#x9;&#x9;&#x9;&#x9;&#x9;SET columnCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;FOR r AS SELECT * FROM /shared/ASAssets/Utilities/string/extractDelimitedText(sqlRow.validation, &apos;|&apos;, 0,0,0,1,0) DO
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET resourceName = r.object;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (resourceName IS NOT NULL AND LENGTH(TRIM(resourceName)) &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET columnCount = columnCount + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;END FOR;
&#x9;&#x9;&#x9;&#x9;&#x9;SET columnMax = columnCount;

&#x9;&#x9;&#x9;&#x9;&#x9;-- Get the Metadata resource path for this procedure
&#x9;&#x9;&#x9;&#x9;&#x9;IF (INSTR(sqlRow.cursType, &apos;DROP PROCEDURE&apos;) &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET resourceName = TRIM(REPLACE(REPLACE(sqlRow.cursType, &apos;DROP PROCEDURE&apos;, &apos;&apos;), &apos;&quot;&apos;, &apos;&apos;));
&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;IF (INSTR(sqlRow.cursType, &apos;DROP FUNCTION&apos;) &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET resourceName = TRIM(REPLACE(REPLACE(sqlRow.cursType, &apos;DROP FUNCTION&apos;, &apos;&apos;), &apos;&quot;&apos;, &apos;&apos;));
&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;SET resourcePath = dataSourceSchemaPath || &apos;/&apos; || resourceName;
&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;        Validate Procedure Path=&apos;||resourcePath);

&#x9;&#x9;&#x9;&#x9;&#x9;-- Get the list of actual columns for the procudure
&#x9;&#x9;&#x9;&#x9;&#x9;SET columnCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;SET columnMissingList = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;BEGIN INDEPENDENT TRANSACTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FOR r AS
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SELECT columnName FROM /shared/ASAssets/Utilities/repository/getBasicResourceCursor_PROCEDURE_CURSOR(resourcePath, &apos;PROCEDURE&apos;, 1)
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;WHERE paramDirection = &apos;IN&apos;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;DO
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (INSTR(LOWER(sqlRow.validation), LOWER(r.columnName)||&apos;|&apos;) &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET columnCount = columnCount + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the &quot;found&quot; column from the validation list
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET sqlRow.validation = TRIM(REPLACE(LOWER(sqlRow.validation), LOWER(r.columnName)||&apos;|&apos;, &apos;&apos;));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (LENGTH(TRIM(columnMissingList)) &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET columnMissingList = columnMissingList || &apos;, &apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET columnMissingList = columnMissingList || LOWER(r.columnName);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END FOR;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Validate the number of columns
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (cursCombinedResult IS NULL) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult || &apos;,  &apos;||CHR(10);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove the pipe at the end of the line
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET len = LENGTH(sqlRow.validation);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (len &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (SUBSTRING(sqlRow.validation, len, 1) = &apos;|&apos;) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET sqlRow.validation = SUBSTRING(sqlRow.validation, 1, len-1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (columnCount = 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET result = &apos;FAIL&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET errorMessage = &apos;FAIL=VALIDATE columns[&apos;||columnCount||&apos;&lt;&gt;&apos;||columnMax||&apos;] &apos;||resourceName || &apos;  Missing columns=[&apos;||sqlRow.validation||&apos;]&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult || errorMessage;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;            &apos;||errorMessage);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSEIF (columnCount &lt;&gt; columnMax) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET result = &apos;FAIL&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET errorMessage = &apos;FAIL=VALIDATE columns[&apos;||columnCount||&apos;&lt;&gt;&apos;||columnMax||&apos;] &apos;||resourceName || &apos;  Procedure columns not in validation list=[&apos;||columnMissingList||&apos;]  Expected columns not found=[&apos;||sqlRow.validation||&apos;]&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult || errorMessage;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;            &apos;||errorMessage);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET errorMessage = &apos;PASS=VALIDATE columns[&apos;||columnCount||&apos;=&apos;||columnMax||&apos;] &apos;||resourceName;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult || errorMessage;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;            &apos;||errorMessage);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET errorMessage = REPLACE(REPLACE(REPLACE(REPLACE(CAST(CURRENT_EXCEPTION.TRACE AS LONGVARCHAR), CHR(10), &apos; &apos;), &apos;    &apos;, &apos; &apos;), &apos;   &apos;, &apos; &apos;), &apos;  &apos;, &apos; &apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (cursCombinedResult IS NULL) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult || &apos;,  &apos;||CHR(10);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IF (INSTR(LOWER(errorMessage), &apos;does not exist&apos;) &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET errorMessage = &apos;FAIL=VALIDATE columns[0&lt;&gt;&apos;||columnMax||&apos;] &apos;||resourceName || &apos;  Resource does not exist&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult || errorMessage;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;            &apos;||errorMessage);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET errorMessage = &apos;FAIL=VALIDATE columns[0&lt;&gt;&apos;||columnMax||&apos;] &apos;||resourceName || &apos;  other exception&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET cursCombinedResult = cursCombinedResult || errorMessage;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CALL PRINT(&apos;        EXCEPTION: Procedure Path=&apos;||resourcePath||&apos;  ERROR=&apos;||errorMessage);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;END;
&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;SET i = i + 1;
&#x9;&#x9;&#x9;END WHILE;
&#x9;&#x9;END IF;

&#x9;&#x9;CALL PRINT(&apos;&apos;);
END</attribute>
  <attribute name="creationDate" type="LONG">1410976495807</attribute>
  <attribute name="creatorUserDomain" type="STRING">ldap</attribute>
  <attribute name="creatorUserName" type="STRING">zkxl6un</attribute>
  <attribute name="explicitly.designed" type="BOOLEAN">false</attribute>
  <attribute name="lastModifiedDate" type="LONG">1601333668980</attribute>
  <attribute name="lastModifiedUserDomain" type="STRING">composite</attribute>
  <attribute name="lastModifiedUserName" type="STRING">admin</attribute>
  <attribute name="model" type="NULL"/>
  <attribute name="native_only" type="STRING">false</attribute>
  <attribute name="references" type="MAP">
    <item>
      <key type="STRING">13/330</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">13/495</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">13/333</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">13/499</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/384</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">13/489</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/524</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/448</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/408</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">12/351</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/409</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/257</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/256</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/425</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/383</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/424</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/512</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">12/327</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/516</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
  </attribute>
</metadata>