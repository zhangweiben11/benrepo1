<?xml version="1.1" encoding="UTF-8"?>
<!-- salt:cde82315-e936-41f1-90c6-32daeeda6afd -->
<metadata name="evaluateResourceOrderBy" path="/shared/Delta_DV/_scripts/Utilities/validate/helpers/evaluateResourceOrderBy" type="PROCEDURE" subtype="SQL_SCRIPT_PROCEDURE" changeToken="0">
  <annotation><![CDATA[evaluateResourceOrderBy

&#x9;This procedure is used to determine whether &quot;order by&quot; is being used within the SQL script except when used
&#x9;&#x9;within the context of analytical functions which is valid.

&#x9;Release:&#x9;Modified Date:&#x9;Modified By:&#x9;&#x9;DV Version:&#x9;&#x9;Reason:
&#x9;2019.200&#x9;04/19/2019&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.8&#x9;&#x9;&#x9;Created new to test for &quot;order by&quot;

&#x9;(c) 2017 TIBCO Software Inc.  All rights reserved.
&#x9;
&#x9;Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
&#x9;The details can be found in the file LICENSE.
&#x9;
&#x9;The following proprietary files are included as a convenience, and may not be used except pursuant
&#x9;to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
&#x9;csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
&#x9;csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
&#x9;and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
&#x9;are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
&#x9;
&#x9;This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
&#x9;If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
&#x9;agreement with TIBCO.]]></annotation>
  <parameters>
    <parameter name="debug" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="inSqlScript" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="containsOrderBy" direction="OUT" nullable="true">
      <datatype name="BIT" type="INTEGER" minValue="0" maxValue="1"/>
    </parameter>
  </parameters>
  <security>
    <owner user="nobody" domain="composite"/>
  </security>
  <dependency target="/lib/debug/Print" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="textToPrint" direction="IN">
        <datatype referenceDefinitionSet="/lib/util/System" referenceType="Text" type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/string/encodedValues" type="DEFINITION_SET">
    <datatype name="Tree" type="TREE" refId="257"></datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/string/findOpenClosePair" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="sqlScript" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="begPos" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="codingList" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="openingDelim" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="closingDelim" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="trimText" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="openingDelimPos" direction="OUT">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="closingDelimPos" direction="OUT">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="extractedScript" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="sqlScriptEncoded" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="extractedScriptBefore" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="extractedScriptAfter" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/string/getCodedString" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="inCodingType" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="inEncodingActions" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="codingList" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inString" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="inModuleNameInvoking" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="inDebug" direction="IN">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
      <element name="inModuleQualifer" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="outString" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/time/getCurrentTimestamp" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="currentTS" direction="OUT">
        <datatype type="DATETIME"/>
      </element>
    </datatype>
  </dependency>
  <attribute name="Script" type="STRING">/*
&#x9;evaluateResourceOrderBy

&#x9;This procedure is used to determine whether &quot;order by&quot; is being used within the SQL script except when used
&#x9;&#x9;within the context of analytical functions which is valid.

&#x9;Release:&#x9;Modified Date:&#x9;Modified By:&#x9;&#x9;DV Version:&#x9;&#x9;Reason:
&#x9;2019.200&#x9;04/19/2019&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.8&#x9;&#x9;&#x9;Created new to test for &quot;order by&quot;

&#x9;(c) 2017 TIBCO Software Inc.  All rights reserved.
&#x9;
&#x9;Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
&#x9;The details can be found in the file LICENSE.
&#x9;
&#x9;The following proprietary files are included as a convenience, and may not be used except pursuant
&#x9;to valid license to Composite Information Server or TIBCO® Data Virtualization Server:
&#x9;csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
&#x9;csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
&#x9;and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
&#x9;are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
&#x9;
&#x9;This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
&#x9;If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
&#x9;agreement with TIBCO.

*/
PROCEDURE evaluateResourceOrderBy(
&#x9;IN debug&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1),
&#x9;IN inSqlScript&#x9;&#x9;&#x9;&#x9;LONGVARCHAR,
&#x9;OUT containsOrderBy&#x9;&#x9;&#x9;BIT&#x9;
)
BEGIN
&#x9;DECLARE moduleName&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT &apos;evaluateResourceOrderBy&apos;;
&#x9;DECLARE debug4&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1) DEFAULT &apos;N&apos;;
&#x9;DECLARE debugPrintSize&#x9;&#x9;&#x9;INTEGER DEFAULT 63000;
&#x9;DECLARE trimText&#x9;&#x9;&#x9;&#x9;INTEGER DEFAULT 0;
&#x9;DECLARE duration&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE currentTS&#x9;&#x9;&#x9;&#x9;TIMESTAMP;
&#x9;DECLARE sectionStartTime&#x9;&#x9;TIMESTAMP;
&#x9;DECLARE sqlScript&#x9;&#x9;&#x9;&#x9;LONGVARCHAR DEFAULT inSqlScript;
&#x9;DECLARE actionTaken&#x9;&#x9;&#x9;&#x9;BOOLEAN;
&#x9;DECLARE word, parentword &#x9;&#x9;LONGVARCHAR default &apos;&apos;;
&#x9;DECLARE grandparentword&#x9;&#x9;&#x9;LONGVARCHAR DEFAULT &apos;&apos;;
&#x9;DECLARE wordcount &#x9;&#x9;&#x9;&#x9;INTEGER DEFAULT 0;
&#x9;DECLARE fromPos, selectPos&#x9;&#x9;INTEGER DEFAULT 0;
&#x9;DECLARE begPos, endPos, asPos&#x9;INTEGER;
&#x9;DECLARE ch&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1);
&#x9;DECLARE len&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE i,x,y&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE pos1,pos2&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE pos1end,pos3,pos4&#x9;&#x9;INTEGER;
&#x9;DECLARE moreToDo1&#x9;&#x9;&#x9;&#x9;BOOLEAN DEFAULT true;
&#x9;DECLARE object&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE objectList1&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE expression1&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE explen1&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;-- Analytical Function List in the syntax of:
&#x9;--&#x9;&#x9;ANALYTICAL_FUNCTION ( [expression] ) OVER ( [PARTITION BY | ORDER BY] expression [, ...])
&#x9;--&#x9;&#x9;ANALYTICAL_FUNCTION ( [expression] ) WITHIN GROUP ( ORDER BY expression [, ...] ) OVER ( [PARTITION BY | ORDER BY] expression [, ...])
&#x9;--&#x9;&#x9;ANALYTICAL_FUNCTION ( [ PARTITION BY expression [, ...] ] ORDER BY expression [ ASC | DESC ] [ NULLS { FIRST | LAST } [, ...])
&#x9;DECLARE analyticalFunctionList&#x9;VARCHAR(1024) DEFAULT &apos;,AVG,COUNT,MIN,MAX,ROW_NUMBER,RANK,MEDIAN,CORR,COVAR_POP,COVAR_SAMP&apos;||
&#x9;&#x9;&apos;,CUME_DIST,DENSE_RANK,FIRST,FIRST_VALUE,LAG,LAST,LAST_VALUE,LEAD,LISTAGG,NTH_VALUE,NTILE,PERCENT_RANK,PERCENTILE,PERCENTILE_APPROX,PERCENTILE_CONT,PERCENTILE_DISC,RATIO_TO_REPORT&apos;||
&#x9;&#x9;&apos;,REGR_AVGX,REGR_AVGY,REGR_COUNT,REGR_INTERCEPT,REGR_R2,REGR_SLOPE,REGR_SXX,REGR_SXY,REGR_SXY,REGR_SYY,STDDEV,STDDEV_POP,STDDEV_SAMP,VAR_POP,VAR_SAMP,VARIANCE&apos;||
&#x9;&#x9;&apos;,&apos;;

&#x9;DECLARE analyticalFunction&#x9;&#x9;VARCHAR;
&#x9;DECLARE analyticalFunctions&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE analyticalFunctionType&#x9;VARCHAR;
&#x9;DECLARE analyticalFuncCount&#x9;&#x9;INTEGER;
&#x9;DECLARE analyticalFuncEnd&#x9;&#x9;INTEGER;
&#x9;DECLARE analyticalFuncPart2&#x9;&#x9;INTEGER;
&#x9;DECLARE continueAnalyticalLoop1&#x9;BOOLEAN;
&#x9;DECLARE continueAnalyticalLoop2&#x9;BOOLEAN;
&#x9;DECLARE encodedComma&#x9;&#x9;&#x9;VARCHAR DEFAULT /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedComma;  &#x9;&#x9;&#x9;&#x9;-- _002C -- &apos;,&apos; comma
&#x9;DECLARE encodedSpace&#x9;&#x9;&#x9;VARCHAR DEFAULT /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedSpace;  &#x9;&#x9;&#x9;&#x9;-- _002E -- &apos; &apos; space
&#x9;DECLARE leftParenPos&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE rightParenPos&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE extractedScript&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE extractedScriptBefore&#x9;LONGVARCHAR; &#x9;-- This is the first extracted &quot;expression&quot; before the opening pair &quot;exp_before P1 ( expression ) exp_after&quot;.
&#x9;DECLARE extractedScriptAfter&#x9;LONGVARCHAR; &#x9;-- This is the first extracted &quot;expression&quot; after the closing pair &quot;exp_before P1 ( expression ) exp_after&quot;.
&#x9;DECLARE operationFound&#x9;&#x9;&#x9;BOOLEAN;
&#x9;DECLARE operandFound&#x9;&#x9;&#x9;BOOLEAN;
&#x9;DECLARE sqlScriptMod&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE otherText&#x9;&#x9;&#x9;&#x9;BOOLEAN;
&#x9;DECLARE doEncoding&#x9;&#x9;&#x9;&#x9;BOOLEAN DEFAULT false;

&#x9;&#x9;SET containsOrderBy = 0;

&#x9;&#x9;/************************************************************************
&#x9;&#x9; *  Place Double Quotes around ANALYTICAL_FUNCTION() OVER ( ) AS COLUMN_ALIAS
&#x9;&#x9;*************************************************************************/
&#x9;&#x9;-- Analytical Function List in the syntax of:
&#x9;&#x9;--&#x9;&#x9;ANALYTICAL_FUNCTION ( [expression] ) OVER ( [PARTITION BY | ORDER BY] expression [, ...])
&#x9;&#x9;--&#x9;&#x9;ANALYTICAL_FUNCTION ( [expression] ) WITHIN GROUP ( ORDER BY expression [, ...] ) OVER ( [PARTITION BY | ORDER BY] expression [, ...])
&#x9;&#x9;--&#x9;&#x9;ANALYTICAL_FUNCTION ( [ PARTITION BY expression [, ...] ] ORDER BY expression [ ASC | DESC ] [ NULLS { FIRST | LAST } [, ...])
&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/&quot;time&quot;/getCurrentTimestamp(sectionStartTime);
&#x9;&#x9;end if;

&#x9;&#x9;-- Convert CR,LF,TAB to space
&#x9;&#x9;set sqlScript = inSqlScript;
&#x9;&#x9;set sqlScript = TRIM(REPLACE(sqlScript,chr(13),&apos; &apos;)); &#x9;-- Carriage return
&#x9;&#x9;set sqlScript = TRIM(REPLACE(sqlScript,chr(10),&apos; &apos;)); &#x9;-- Line Feed
&#x9;&#x9;set sqlScript = TRIM(REPLACE(sqlScript,chr(9), &apos; &apos;));&#x9;-- Tab
&#x9;&#x9;-- Insure there are spaces around left and right parenthesis
&#x9;&#x9;set sqlScript = REPLACE(sqlScript, &apos;)&apos;, &apos; ) &apos;);
&#x9;&#x9;set sqlScript = REPLACE(sqlScript, &apos;(&apos;, &apos; ( &apos;);
&#x9;&#x9;-- Insure there are spaces around commas
&#x9;&#x9;set sqlScript = REPLACE(sqlScript, &apos;,&apos;, &apos; , &apos;);

&#x9;&#x9;set actionTaken = false;
&#x9;&#x9;-- Reduce the number of double spaces to a single space
&#x9;&#x9;while (INSTR(sqlScript, &apos;  &apos;) &gt; 0) do
&#x9;&#x9;&#x9;set actionTaken = true;
&#x9;&#x9;&#x9;set sqlScript = REPLACE(sqlScript, &apos;  &apos;, &apos; &apos;);
&#x9;&#x9;end while;

&#x9;&#x9;-- Convert the string WITHIN GROUP to WITHIN_GROUP so that it is a single word for parsing purposes.
&#x9;&#x9;--&#x9;WITHIN GROUP is used by: LISTAGG, PERCENTILE_CONT, PERCENTILE_DISC
&#x9;&#x9;set pos1 = INSTR(UPPER(sqlScript), &apos; WITHIN GROUP &apos;);
&#x9;&#x9;while (pos1 &gt; 0) do
&#x9;&#x9;&#x9;set sqlScript = SUBSTRING(sqlScript, 1, pos1-1) || &apos; WITHIN_GROUP &apos;|| SUBSTRING(sqlScript,pos1+14);
&#x9;&#x9;&#x9;set pos1 = INSTR(UPPER(sqlScript), &apos; WITHIN GROUP &apos;);
&#x9;&#x9;end while;
&#x9;&#x9;-- Convert the string FROM FIRST to FROM_FIRST so that it is a single word for parsing purposes.
&#x9;&#x9;--&#x9;FROM FIRST is used by: NTH_VALUE
&#x9;&#x9;set pos1 = INSTR(UPPER(sqlScript),&apos; FROM FIRST &apos;);
&#x9;&#x9;while (pos1 &gt; 0) do
&#x9;&#x9;&#x9;set sqlScript = SUBSTRING(sqlScript, 1, pos1-1) || &apos; FROM_FIRST &apos;|| SUBSTRING(sqlScript,pos1+12);
&#x9;&#x9;&#x9;set pos1 = INSTR(UPPER(sqlScript),&apos; FROM FIRST &apos;);
&#x9;&#x9;end while;
&#x9;&#x9;-- Convert the string FROM LAST to FROM_LAST so that it is a single word for parsing purposes.
&#x9;&#x9;--&#x9;FROM LAST is used by: NTH_VALUE
&#x9;&#x9;set pos1 = INSTR(UPPER(sqlScript),&apos; FROM LAST &apos;);
&#x9;&#x9;while (pos1 &gt; 0) do
&#x9;&#x9;&#x9;set sqlScript = SUBSTRING(sqlScript, 1, pos1-1) || &apos; FROM_LAST &apos;|| SUBSTRING(sqlScript,pos1+11);
&#x9;&#x9;&#x9;set pos1 = INSTR(UPPER(sqlScript),&apos; FROM LAST &apos;);
&#x9;&#x9;end while;

&#x9;&#x9;--   Example: &quot;ROW_NUMBER() over (partition by SOURCE_ID, A, B, ORDER BY C)&quot; AS SEQ
&#x9;&#x9;SET analyticalFunctions = null;
&#x9;&#x9;-- Extract the object from the list
&#x9;&#x9;SET objectList1 = analyticalFunctionList;
&#x9;&#x9;SET expression1 = &apos;,&apos;;
&#x9;&#x9;SET explen1 = length(expression1);
&#x9;&#x9;SET moreToDo1 = true;
&#x9;&#x9;SET x = 0;
&#x9;&#x9;WHILE (moreToDo1) DO
&#x9;&#x9;&#x9;-- Extract the source column type
&#x9;&#x9;&#x9;SET x = x + 1;
&#x9;&#x9;&#x9;SET object = null;
&#x9;&#x9;&#x9;IF (x = 1) THEN
&#x9;&#x9;&#x9;&#x9;SET pos1 = INSTR(objectList1, expression1, 1, x);
&#x9;&#x9;&#x9;&#x9;IF (pos1 &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;SET object = SUBSTRING(objectList1, 1, pos1-1);
&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;IF (LENGTH(TRIM(objectList1)) &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET object = objectList1;
&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;SET moreToDo1 = false;
&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;SET pos1 = INSTR(objectList1, expression1, 1, x-1);
&#x9;&#x9;&#x9;&#x9;SET pos2 = INSTR(objectList1, expression1, 1, x);
&#x9;&#x9;&#x9;&#x9;IF (pos1 &gt; 0 and pos2 &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;SET object = SUBSTRING(objectList1, pos1+explen1, pos2-pos1-explen1);
&#x9;&#x9;&#x9;&#x9;ELSEIF (pos1 &gt; 0 and pos2 = 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;SET object = SUBSTRING(objectList1, pos1+explen1);
&#x9;&#x9;&#x9;&#x9;&#x9;SET moreToDo1 = false;
&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;SET moreToDo1 = false;
&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;SET object = TRIM(object);
&#x9;&#x9;&#x9;--CALL PRINT(&apos;object=&apos;||TRIM(NVL(object,&apos;  &apos;)));
&#x9;&#x9;&#x9;IF (object IS NOT NULL and LENGTH(TRIM(object)) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;set analyticalFunction = object;

&#x9;&#x9;&#x9;&#x9;set endPos = 1;
&#x9;&#x9;&#x9;&#x9;set analyticalFuncCount = 0;
&#x9;&#x9;&#x9;&#x9;set continueAnalyticalLoop1 = true;
&#x9;&#x9;&#x9;&#x9;while (continueAnalyticalLoop1) do
&#x9;&#x9;&#x9;&#x9;&#x9;/***************************************************************************************
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Get the position again looking for the next occurrence of the analytical function
&#x9;&#x9;&#x9;&#x9;&#x9;****************************************************************************************/
&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncCount = analyticalFuncCount + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : PARSE ANALYTICAL FUNCTION: &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;()  SEARCHING...count=&apos;||analyticalFuncCount);
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;set pos2 = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;set pos3 = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;set pos4 = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;set pos1end = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncEnd = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncPart2 = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctionType = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;set pos1 = INSTR(UPPER(sqlScript),analyticalFunction||&apos; (&apos;, endPos);
&#x9;&#x9;&#x9;&#x9;&#x9;if (pos1 &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Find the end of the analytical function part1: analytical_func ( expression )
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--                                                                             ^-pos1end
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Search through the sql script to find the corresponding right paren ) for the starting left paren (
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- This assumes there is only a single outer () pair such as P1(  P2 ( ) ).  This pattern is not supported in this context: P1 ( )  P2 ( )
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- By finding the logical end to the analytical function part 1, is insures that the follow-on searches will have no issues 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--&#x9;&#x9;with embedded commas or other search text that might interfere with the rest of the searches.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/findOpenClosePair(sqlScript, pos1, encodedComma, &apos;(&apos;,&apos;)&apos;, trimText, leftParenPos, rightParenPos, extractedScript, sqlScriptMod, extractedScriptBefore, extractedScriptAfter);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;(): VALIDATING...pos1:findOpenClosePair sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (rightParenPos &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set pos1end = rightParenPos;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (sqlScriptMod is not null) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlScript = sqlScriptMod;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Find the position of &apos; WITHIN_GROUP &apos; and/or &apos; OVER &apos;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- They both may exist in the same function for LISTAGG, PERCENTILE_CONT and PERCENTILE_DISC
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set pos2 = INSTR(UPPER(sqlScript),&apos; WITHIN_GROUP &apos;,pos1end);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos2 &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/findOpenClosePair(sqlScript, pos2, encodedComma, &apos;(&apos;,&apos;)&apos;, trimText, leftParenPos, rightParenPos, extractedScript, sqlScriptMod, extractedScriptBefore, extractedScriptAfter);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() WITHIN GROUP(): VALIDATING...pos2:findOpenClosePair sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (sqlScriptMod is not null) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlScript = sqlScriptMod;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set pos3 = INSTR(UPPER(sqlScript),&apos; OVER &apos;,pos1end);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos3 &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/findOpenClosePair(sqlScript, pos3, encodedComma, &apos;(&apos;,&apos;)&apos;, trimText, leftParenPos, rightParenPos, extractedScript, sqlScriptMod, extractedScriptBefore, extractedScriptAfter);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() OVER(): VALIDATING...pos3:findOpenClosePair sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (sqlScriptMod is not null) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlScript = sqlScriptMod;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Find the first occurrence of a comma, &quot;AS&quot; or &quot;FROM&quot; following the analytical function.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- The objective is to compare the position of &quot;WITHIN_GROUP&quot;/&quot;OVER&quot; w.r.t. where the comma separates this column. 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- If &quot;WITHIN_GROUP&quot;/&quot;OVER&quot; is between pos and pos4 then this is valid.  If &quot;WITHIN_GROUP&quot;/&quot;OVER&quot; is greater than pos4 then this
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--&#x9;is not an analytical function.  For example, MIN and MAX is a function with OVER and without OVER.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set pos4 = INSTR(sqlScript, &apos;,&apos;, pos1end);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set asPos = INSTR(UPPER(sqlScript),&apos; AS &apos;, pos1end);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set fromPos = INSTR(UPPER(sqlScript),&apos; FROM &apos;, pos1end);

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Determine which one or both of &quot;WITHIN GROUP&quot;/&quot;OVER&quot; exists and which position is greater than the other.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Example 1:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- PERCENTILE_DISC(cola,&apos;&apos;,&apos;&apos;) within group (order by colb ASC) OVER (partition by colc, cola, cold) AS AF10     FROM tablename
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- ^-pos1=1                    ^-pos2=29                        ^-pos3=62                            ^-aspos=99  ^-frompos=112           [pos4=aspos=99]
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Example 2:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- LISTAGG(cola,&apos;,&apos;) WITHIN GROUP (ORDER BY colb DESC, colc NULLS FIRST) AS      AF11,          RANK()     over (order by MAX(cold) DESCENDING ) AF12   FROM tablename
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- ^-pos1=1          ^-pos2=19                                           ^-aspos=71  ^pos4=83   ^-pos1=94  ^-pos3=105                                   ^-frompos=150     [pos4=aspos=71]

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Calculate the end of this analytical function
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncEnd = pos4;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos4 = 0 or (asPos &gt; 0 and asPos &lt; pos4)) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncEnd = asPos;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos4 = 0 or (fromPos &gt; 0 and fromPos &lt; pos4)) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncEnd = fromPos;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Calculate whether &quot;WITHIN_GROUP&quot; or &quot;OVER&quot; is greater than the other and less than the end of this analytical function.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--    The code only needs to know the position of the greater one when both exist so that it can locate the right-most parenthesis &quot;)&quot;.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- &quot;WITHIN_GROUP&quot; was found and &quot;OVER&quot; was not found
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos2 &gt; 0 and pos3 = 0 and pos2 &lt; analyticalFuncEnd and pos3 &lt; analyticalFuncEnd) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncPart2 = pos2;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctionType = &apos;WITHIN GROUP()&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- &quot;WITHIN_GROUP&quot; was not found &quot;OVER&quot; was found
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos2 = 0 and pos3 &gt; 0 and pos2 &lt; analyticalFuncEnd and pos3 &lt; analyticalFuncEnd) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncPart2 = pos3;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctionType = &apos;OVER()&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- &quot;WITHIN_GROUP&quot; was found and &quot;OVER&quot; was found
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos2 &gt; 0 and pos3 &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Choose &quot;OVER&quot; postion when both have been found and both are less than the analytical end.  
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--&#x9;&#x9;We just need the greatest position number to start search from.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos2 &lt; analyticalFuncEnd and pos3 &lt; analyticalFuncEnd) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos3 &gt; pos2) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncPart2 = pos3;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctionType = &apos;WITHIN GROUP() OVER()&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Choose &quot;OVER&quot; postion when both have been found and pos3 is less than the analytical end and pos2 is not.  
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos2 &gt; analyticalFuncEnd and pos3 &lt; analyticalFuncEnd) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncPart2 = pos3;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctionType = &apos;WITHIN GROUP() OVER()&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Choose &quot;WITHIN GROUP&quot; postion when both have been found and pos2 is less than the analytical end and pos3 is not.  
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos2 &lt; analyticalFuncEnd and pos3 &gt; analyticalFuncEnd) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFuncPart2 = pos2;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctionType = &apos;WITHIN GROUP() OVER()&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos;: VALIDATING...&apos;||
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&apos;  pos1=&apos;||pos1||&apos;  pos2=&apos;||pos2||&apos;  pos3=&apos;||pos3||&apos;  pos4=&apos;||pos4||&apos;  asPos=&apos;||asPos||&apos;  fromPos=&apos;||fromPos||
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&apos;  analyticalFuncPart2=&apos;||analyticalFuncPart2||&apos;  analyticalFuncEnd=&apos;||analyticalFuncEnd);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (continueAnalyticalLoop1 and pos1 &gt; 0 and analyticalFuncPart2 &gt; pos1 and analyticalFuncPart2 &lt; analyticalFuncEnd) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos; FOUND...begin sqlScript=[&apos;||SUBSTRING(RTRIM(NVL(sqlScript,&apos;  &apos;)),1,debugPrintSize)||&apos;...&apos;||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Keep track of which analytical functions were found
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (analyticalFunctions is null) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctions = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctions = analyticalFunctions || analyticalFunction;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Only add the analytical function to the list if it does not exist.  Only need 1 occurrence of the function to report on.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (INSTR(analyticalFunctions||&apos;,&apos;, analyticalFunction||&apos;,&apos;) = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctions = analyticalFunctions || &apos;,&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set analyticalFunctions = analyticalFunctions || analyticalFunction;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Search through the sql script to find the corresponding right paren ) for the starting left paren (
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- This assumes there is only a single outer () pair such as P1(  P2 ( ) ).  This pattern is not supported in this context: P1 ( )  P2 ( )
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/findOpenClosePair(sqlScript, analyticalFuncPart2, null, &apos;(&apos;,&apos;)&apos;, trimText, leftParenPos, rightParenPos, extractedScript, sqlScriptMod, extractedScriptBefore, extractedScriptAfter);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = rightParenPos + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set begPos = pos1; -- beginning position is where the analytical function begins
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set endPos = rightParenPos + 1; -- Assume the end position the right paren + 1
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos;: FOUND...&apos;||
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&apos;  begPos=&apos;||begPos||&apos;  endPos=&apos;||endPos||&apos;  rightParenPos=&apos;||rightParenPos||
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&apos;  functionEnd:findOpenClosePair sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Look for additional operations following OVER() such as OVER(...) - 1 AS aliasname
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set word = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set continueAnalyticalLoop2 = true;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set operationFound = false;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set operandFound = false;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set otherText = false;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set len = LENGTH(sqlScript);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (i &lt;= len and continueAnalyticalLoop2) do
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set ch = substring(sqlScript,i,1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;ch=[&apos;||ch||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch &lt;&gt; &apos; &apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch in (&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;)) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (not otherText) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set operationFound = true;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (ch in (&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;)) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (not otherText) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set operandFound = true;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (ch = &apos;,&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set continueAnalyticalLoop2 = false;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set otherText = true;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set word = word || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;otherText=&apos;||cast(otherText as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;operationFound=&apos;||cast(operationFound as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;operandFound=&apos;||cast(operandFound as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;word=&apos;||word);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (operationFound and operandFound) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set continueAnalyticalLoop2 = false;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set endPos = i;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (UPPER(word) = &apos;AS&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set continueAnalyticalLoop2 = false;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (UPPER(word) = &apos;FROM&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set continueAnalyticalLoop2 = false;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set word = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = i + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end while;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos;:  FOUND...after function operation begPos=&apos;||begPos||&apos;  endPos=&apos;||endPos||&apos;  operationFound=&apos;||cast(operationFound as varchar)||&apos;  operandFound=&apos;||cast(operandFound as varchar)||&apos;  otherText=&apos;||cast(otherText as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Remove all text between left paren ( and right paren ) as it is inconsequential for parsing.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (begPos = 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlScriptMod = &apos;&quot;&apos;||SUBSTRING(sqlScript, begPos, endPos-begPos)||&apos;&quot;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlScript = &apos; &apos;||sqlScriptMod||SUBSTRING(sqlScript,endPos);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set doEncoding = true;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlScriptMod = &apos;&quot;&apos;||SUBSTRING(sqlScript, begPos, endPos-begPos)||&apos;&quot;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set sqlScript = &apos; &apos;||SUBSTRING(sqlScript, 1, begPos-1)||sqlScriptMod||SUBSTRING(sqlScript,endPos);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set doEncoding = true;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; :     &apos;||RTRIM(NVL(analyticalFunction,&apos;  &apos;))||&apos;() &apos;||analyticalFunctionType||&apos;: FOUND...double quoted sqlScriptMod=[&apos;||SUBSTRING(RTRIM(NVL(sqlScriptMod,&apos;  &apos;)),1,debugPrintSize)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Set the position in which to start searching for the same function name within the existing sqlScriptMod
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set endPos = endPos - 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Set the position in which to start searching for the same function name within the existing sqlScriptMod
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set endPos = pos1 + length(analyticalFunction);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set continueAnalyticalLoop1 = false;
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;end while;
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;END WHILE;
&#x9;&#x9;set sqlScript = &apos; &apos;||TRIM(sqlScript);
&#x9;&#x9;if (doEncoding) then
&#x9;&#x9;&#x9;set actionTaken = true;
&#x9;&#x9;&#x9;if (INSTR(sqlScript, &apos;&quot;&apos;) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/getCodedString(&apos;E&apos;, &apos;D&apos;, encodedSpace, sqlScript, moduleName, debug4, &apos;sqlScript&apos;, sqlScript);
&#x9;&#x9;&#x9;end if;
&#x9;&#x9;end if;

&#x9;&#x9;-- Determine if an order by is present
&#x9;&#x9;if (INSTR(lower(sqlScript), &apos;order by&apos;) &gt; 0) then
&#x9;&#x9;&#x9;set containsOrderBy = 1;
&#x9;&#x9;end if;

&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/&quot;time&quot;/getCurrentTimestamp(currentTS);
&#x9;&#x9;&#x9;set duration = cast(currentTS - sectionStartTime as varchar);
&#x9;&#x9;&#x9;call print(moduleName||&apos; : duration=&apos;||RPAD(duration,12,&apos; &apos;)||&apos;  actionTaken=&apos;||RPAD(cast(actionTaken as varchar),5,&apos; &apos;)||&apos;  PARSE ANALYTICAL FUNCTIONS: [&apos;||RTRIM(NVL(analyticalFunctions,&apos;NONE&apos;))||&apos;]() final sqlScript=[&apos;||SUBSTRING(RTRIM(NVL(sqlScript,&apos;  &apos;)),1,debugPrintSize)||&apos;...&apos;||&apos;]&apos;);
&#x9;&#x9;end if;

END</attribute>
  <attribute name="creationDate" type="LONG">1549320149243</attribute>
  <attribute name="creatorUserDomain" type="STRING">composite</attribute>
  <attribute name="creatorUserId" type="INTEGER">-1973</attribute>
  <attribute name="creatorUserName" type="STRING">admin</attribute>
  <attribute name="explicitly.designed" type="BOOLEAN">false</attribute>
  <attribute name="lastModifiedDate" type="LONG">1609965948495</attribute>
  <attribute name="lastModifiedUserDomain" type="STRING">composite</attribute>
  <attribute name="lastModifiedUserId" type="INTEGER">-1973</attribute>
  <attribute name="lastModifiedUserName" type="STRING">admin</attribute>
  <attribute name="model" type="NULL"/>
  <attribute name="native_only" type="STRING">false</attribute>
  <attribute name="references" type="MAP">
    <item>
      <key type="STRING">14/232</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/222</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">13/298</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/376</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">12/188</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/389</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/326</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/305</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">13/207</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/419</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
  </attribute>
  <attribute name="resourceModifiedDateOnSourceCISSite" type="LONG">1549320149243</attribute>
</metadata>