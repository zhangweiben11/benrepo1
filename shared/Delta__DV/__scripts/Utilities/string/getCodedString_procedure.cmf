<?xml version="1.1" encoding="UTF-8"?>
<!-- salt:cde82315-e936-41f1-90c6-32daeeda6afd -->
<metadata name="getCodedString" path="/shared/Delta_DV/_scripts/Utilities/string/getCodedString" type="PROCEDURE" subtype="SQL_SCRIPT_PROCEDURE" changeToken="0">
  <annotation><![CDATA[getCodedString - Perform encoding or decoding of special characters within double quoted, single quoted or parenthesis pair strings

&#x9;Input:
&#x9;&#x9;inCodingType&#x9;&#x9;&#x9;- The type of coding to perform. E=encode special characters, D=decode special characters
&#x9;&#x9;&#x9;e.g. when codingType=E then encode from /a/b/&quot;1_002e3_0020c&quot;/&quot;_0020d_0020&quot;/&quot;1_002c2_0021&quot;/&quot;_0020_0021_0020_0025_0020_0028_0020_0029_0020_002a_0020_002b_0020_002d_0020_002f_0020&quot;
&#x9;&#x9;&#x9;e.g. when codingType=D then decode from /a/b/&quot;1.3 c&quot;/&quot; d &quot;/&quot;1,2!&quot;/&quot; ! % ( ) * + - / &quot;
&#x9;&#x9;inEncodingActions&#x9;&#x9;- A directive on which action to take. A space or comma separated list of directives below:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;P=encode/decode between Parenthesis, 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;D=encode/decode between double quotes, 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;S=encode/decode between single quotes, 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;N=encode/decode anywhere in the string,
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;null when codingType=D (this parameter is ignored)
&#x9;&#x9;codingList&#x9;&#x9;&#x9;&#x9;- A comma separate list of encoded values to encode or decode.  e.g. _0020,_002c,_002e or HEXADECIMAL in conjunction with inEncodingActions=S
&#x9;&#x9;inString&#x9;&#x9;&#x9;&#x9;- The string to encode or decode
&#x9;&#x9;inModuleNameInvoking&#x9;- The module from which this script is being invoked.
&#x9;&#x9;inDebug&#x9;&#x9;&#x9;&#x9;&#x9;- Debug: Y or N
&#x9;&#x9;inStringName&#x9;&#x9;&#x9;- The name or type of inString being encoded/decoded to be used for debugging purposes.
&#x9;Output:
&#x9;&#x9;outString&#x9;&#x9;- The resulting string
&#x9;Exceptions:  none

&#x9;Release:&#x9;Modified Date:&#x9;Modified By:&#x9;&#x9;DV Version:&#x9;&#x9;Reason:
&#x9;2013.4&#x9;&#x9;10/28/2013&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;6.2.0&#x9;&#x9;&#x9;8.0: new.  Perform a string encode or decode of special characters
&#x9;2015.1&#x9;&#x9;11/20/2014&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;6.2.6&#x9;&#x9;&#x9;8.1.5: Added implementation for DECODE to recognize encodingActions=P,D,S
&#x9;2015.4&#x9;&#x9;11/02/2015&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.2&#x9;&#x9;&#x9;KPI: Adapted from Data Abstraction Best Practices to use with KPI for SQL Statement parsing and colunm extraction.
&#x9;2017.2&#x9;&#x9;03/07/2017&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.5&#x9;&#x9;&#x9;Fixed bug. Removed the TRIM from: SET object = UPPER(object); -- DO NOT TRIM
&#x9;2018.100&#x9;03/02/2018&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.5&#x9;&#x9;&#x9;Replaced RegexSplit with extractDelimitedText
&#x9;2019.200&#x9;04/19/2019&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.8&#x9;&#x9;&#x9;Migrated to Utilities from KPImetrics

&#x9;(c) 2017 TIBCO Software Inc. All rights reserved.
&#x9;
&#x9;Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
&#x9;The details can be found in the file LICENSE.
&#x9;
&#x9;The following proprietary files are included as a convenience, and may not be used except pursuant
&#x9;to valid license to Composite Information Server or TIBCOÂ® Data Virtualization Server:
&#x9;csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
&#x9;csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
&#x9;and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
&#x9;are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
&#x9;
&#x9;This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
&#x9;If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
&#x9;agreement with TIBCO.]]></annotation>
  <parameters>
    <parameter name="inCodingType" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="inEncodingActions" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
      <attribute name="Customized" type="STRING">datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed</attribute>
    </parameter>
    <parameter name="codingList" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="inString" direction="IN" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
    <parameter name="inModuleNameInvoking" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="inDebug" direction="IN" nullable="true">
      <datatype name="CHAR" type="STRING" minLength="1" maxLength="1"/>
    </parameter>
    <parameter name="inModuleQualifer" direction="IN" nullable="true">
      <datatype name="VARCHAR" type="STRING" maxLength="255"/>
    </parameter>
    <parameter name="outString" direction="OUT" nullable="true">
      <datatype name="LONGVARCHAR" type="STRING" maxLength="2147483647"/>
    </parameter>
  </parameters>
  <security>
    <owner user="nobody" domain="composite"/>
  </security>
  <dependency target="/lib/debug/Print" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="textToPrint" direction="IN">
        <datatype referenceDefinitionSet="/lib/util/System" referenceType="Text" type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/services/databases/system/DUAL" type="TABLE">
    <datatype type="TABLE" refId="256">
      <element name="DUMMY">
        <datatype type="STRING" minLength="1" maxLength="1"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/encoding/EncodingCJP/DecryptFrom3DES" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="encrypted hex string" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="digest seed" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="plain text" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/encoding/EncodingCJP/EncryptWith3DES" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="plain text" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="digest seed" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="encrypted raw bytes" direction="OUT">
        <datatype type="BINARY" maxLength="2147483647"/>
      </element>
      <element name="encrypted hex string" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/string/TextUtils/RegexReplace" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="Input Text" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="Regular Expression" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="Replacement Text" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="Occurrence" direction="IN">
        <datatype type="INTEGER" minValue="-2147483648" maxValue="2147483647"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/string/encodedValues" type="DEFINITION_SET">
    <datatype name="Tree" type="TREE" refId="257"></datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/string/extractDelimitedText" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="inputString" direction="IN">
        <datatype type="STRING" maxLength="2147483647"/>
      </element>
      <element name="delimiter" direction="IN">
        <datatype type="STRING" maxLength="255"/>
      </element>
      <element name="occurrence" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="reverseInputText" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="reverseOutput" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="trimText" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="includeDelimiter" direction="IN">
        <datatype type="INTEGER" minValue="-32768" maxValue="32767"/>
      </element>
      <element name="result" direction="OUT">
        <datatype type="TABLE" refId="256">
          <element name="object">
            <datatype type="STRING" maxLength="2147483647"/>
          </element>
        </datatype>
      </element>
    </datatype>
  </dependency>
  <dependency target="/shared/Delta_DV/_scripts/Utilities/time/getCurrentTimestamp" type="PROCEDURE">
    <datatype type="PROCEDURE" refId="258">
      <element name="currentTS" direction="OUT">
        <datatype type="DATETIME"/>
      </element>
    </datatype>
  </dependency>
  <attribute name="Script" type="STRING">/*
&#x9;getCodedString:

&#x9;Perform encoding or decoding of special characters within double quoted, single quoted or parenthesis pair strings.

&#x9;Input:
&#x9;&#x9;inCodingType&#x9;&#x9;&#x9;- The type of coding to perform. 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;E=encode special characters, 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.g. encode from /a/b/&quot;1_002e3_0020c&quot;/&quot;_0020d_0020&quot;/&quot;1_002c2_0021&quot;/&quot;_0020_0021_0020_0025_0020_0028_0020_0029_0020_002a_0020_002b_0020_002d_0020_002f_0020&quot;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;D=decode special characters
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.g. decode from /a/b/&quot;1.3 c&quot;/&quot; d &quot;/&quot;1,2!&quot;/&quot; ! % ( ) * + - / &quot;
&#x9;&#x9;inEncodingActions&#x9;&#x9;- A directive on which action to take. A space or comma separated list of directives below:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;P=encode/decode between Parenthesis, 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;D=encode/decode between double quotes, 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;S=encode/decode between single quotes, 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;N=encode/decode anywhere in the string,
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;null when codingType=D (this parameter is ignored)
&#x9;&#x9;codingList&#x9;&#x9;&#x9;&#x9;- A comma separate list of encoded values to encode or decode.  e.g. _0020,_002c,_002e or HEXADECIMAL in conjunction with inEncodingActions=S
&#x9;&#x9;inString&#x9;&#x9;&#x9;&#x9;- The string to encode or decode
&#x9;&#x9;inModuleNameInvoking&#x9;- The module from which this script is being invoked.
&#x9;&#x9;inDebug&#x9;&#x9;&#x9;&#x9;&#x9;- Debug: Y or N
&#x9;&#x9;inModuleQualifer&#x9;&#x9;- The module qualifier is a name or type of the &quot;inString&quot; being encoded/decoded to be used for debugging purposes.
&#x9;Output:
&#x9;&#x9;outString&#x9;&#x9;- The result string
&#x9;Exceptions:  none

&#x9;Release:&#x9;Modified Date:&#x9;Modified By:&#x9;&#x9;DV Version:&#x9;&#x9;Reason:
&#x9;2013.4&#x9;&#x9;10/28/2013&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;6.2.0&#x9;&#x9;&#x9;8.0: new.  Perform a string encode or decode of special characters
&#x9;2015.1&#x9;&#x9;11/20/2014&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;6.2.6&#x9;&#x9;&#x9;8.1.5: Added implementation for DECODE to recognize encodingActions=P,D,S
&#x9;2015.4&#x9;&#x9;11/02/2015&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.2&#x9;&#x9;&#x9;KPI: Adapted from Data Abstraction Best Practices to use with KPI for SQL Statement parsing and colunm extraction.
&#x9;2017.2&#x9;&#x9;03/07/2017&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.5&#x9;&#x9;&#x9;Fixed bug. Removed the TRIM from: SET object = UPPER(object); -- DO NOT TRIM
&#x9;2018.100&#x9;03/02/2018&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.5&#x9;&#x9;&#x9;Replaced RegexSplit with extractDelimitedText
&#x9;2019.200&#x9;04/19/2019&#x9;&#x9;Mike Tinius&#x9;&#x9;&#x9;7.0.8&#x9;&#x9;&#x9;Migrated to Utilities from KPImetrics

&#x9;(c) 2017 TIBCO Software Inc. All rights reserved.
&#x9;
&#x9;Except as specified below, this software is licensed pursuant to the Eclipse Public License v. 1.0.
&#x9;The details can be found in the file LICENSE.
&#x9;
&#x9;The following proprietary files are included as a convenience, and may not be used except pursuant
&#x9;to valid license to Composite Information Server or TIBCOÂ® Data Virtualization Server:
&#x9;csadmin-XXXX.jar, csarchive-XXXX.jar, csbase-XXXX.jar, csclient-XXXX.jar, cscommon-XXXX.jar,
&#x9;csext-XXXX.jar, csjdbc-XXXX.jar, csserverutil-XXXX.jar, csserver-XXXX.jar, cswebapi-XXXX.jar,
&#x9;and customproc-XXXX.jar (where -XXXX is an optional version number).  Any included third party files
&#x9;are licensed under the terms contained in their own accompanying LICENSE files, generally named .LICENSE.txt.
&#x9;
&#x9;This software is licensed AS-IS. Support for this software is not covered by standard maintenance agreements with TIBCO.
&#x9;If you would like to obtain assistance with this software, such assistance may be obtained through a separate paid consulting
&#x9;agreement with TIBCO.

*/
PROCEDURE getCodedString(
&#x9;IN  inCodingType&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- The type of coding to perform. E=encode special characters, D=decode special characters
&#x9;IN  inEncodingActions&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- A directive on which action to take.  A space or comma separated list of directives below:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--   P=encode/decode between Parenthesis
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--   D=encode/decode between double quotes
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--   S=encode/decode between single quotes
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--   N=encode/decode anywhere in the string
&#x9;IN  codingList&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- A comma separated list of encoded values to encode or decode.  e.g. _0020,_002c,_002e or HEXADECIMAL in conjunction with inEncodingActions=S
&#x9;IN  inString&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR,-- The string to encode or decode
&#x9;IN  inModuleNameInvoking&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- The module from which this script is being invoked.
&#x9;IN  inDebug&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1),&#x9;-- Debug: Y or N
&#x9;IN  inModuleQualifer&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR,&#x9;-- The module qualifier is a name or type of the &quot;inString&quot; being encoded/decoded to be used for debugging purposes.
&#x9;OUT outString&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR -- The resulting string
)
BEGIN
&#x9;DECLARE moduleName&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT &apos;getCodedString&apos;;
&#x9;DECLARE debug&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1) DEFAULT inDebug;
&#x9;DECLARE debugTime&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1) DEFAULT &apos;N&apos;;
&#x9;DECLARE debugPrintSize&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER DEFAULT 60000;
&#x9;DECLARE codingType&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1) DEFAULT UPPER(inCodingType);
&#x9;DECLARE encodingActions&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT UPPER(inEncodingActions);
&#x9;DECLARE moduleNameInvoking&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT TRIM(NVL(inModuleNameInvoking,&apos;  &apos;));
&#x9;DECLARE newline&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT CHR(10);
&#x9;DECLARE regexSize&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER DEFAULT 200000;
&#x9;DECLARE regexOccurrenceMax&#x9;&#x9;&#x9;&#x9;INTEGER DEFAULT 2000;
&#x9;DECLARE encodingAction&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1); -- P D S
&#x9;DECLARE actualValue&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE codedValue&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE escapeValueList&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT &apos;&quot;&quot;$^\&apos;&apos;&apos;;
&#x9;-- Append the actual value to this string.  This is not the encoded value.
&#x9;-- encodingAction=P
&#x9;DECLARE regexReplacePatternParentheses&#x9;VARCHAR DEFAULT &apos;(?=[^()]{0,&apos;||regexSize||&apos;}\))&apos;;
&#x9;-- encodingAction=DQ
&#x9;DECLARE regexReplacePatternDoubleQuote &#x9;VARCHAR DEFAULT &apos;(?=[^&quot;]{0,&apos;||regexSize||&apos;}&quot;(?:[^&quot;\r\n]{0,&apos;||regexSize||&apos;}&quot;[^&quot;]{0,&apos;||regexSize||&apos;}&quot;){0,&apos;||regexSize||&apos;}[^&quot;\r\n]{0,&apos;||regexSize||&apos;}$)&apos;;
&#x9;-- encodingAction=SQ
&#x9;DECLARE regexReplacePatternSingleQuote &#x9;VARCHAR DEFAULT &apos;(?=[^&apos;&apos;]{0,&apos;||regexSize||&apos;}&apos;&apos;(?:[^&apos;&apos;\r\n]{0,&apos;||regexSize||&apos;}&apos;&apos;[^&apos;&apos;]{0,&apos;||regexSize||&apos;}&apos;&apos;){0,&apos;||regexSize||&apos;}[^&apos;&apos;\r\n]{0,&apos;||regexSize||&apos;}$)&apos;;
&#x9;DECLARE regexPattern&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR(1024);
&#x9;DECLARE startTime&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
&#x9;DECLARE endTime&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TIMESTAMP;
&#x9;DECLARE duration&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTERVAL MINUTE TO SECOND;
&#x9;DECLARE seconds&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;DECIMAL(32,3);
&#x9;DECLARE defaultActionType&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT &apos;NO_ACTION:&apos;;
&#x9;DECLARE actionType&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT defaultActionType;
&#x9;DECLARE tempString&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE encryptedRawBytes&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE encryptedHex&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE encryptedHexValuePair&#x9;&#x9;&#x9;LONGVARCHAR DEFAULT &apos;&apos;;
&#x9;DECLARE encodedDoubleDoubleQuote&#x9;&#x9;VARCHAR DEFAULT /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedDoubleDoubleQuote;
&#x9;DECLARE outStringTemp&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR DEFAULT &apos;&apos;;
&#x9;DECLARE i, pos&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE iterations&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE quoteCount&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER DEFAULT 0;
&#x9;DECLARE parenCount&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE leftPos&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER DEFAULT 0;
&#x9;DECLARE rightPos&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER DEFAULT 0;
&#x9;DECLARE numOccurrences&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE ch&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CHAR(1);
&#x9;DECLARE x&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE pos1,pos2&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE moreToDo1&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;BOOLEAN DEFAULT true;
&#x9;DECLARE object&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE objectList1&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LONGVARCHAR;
&#x9;DECLARE expression1&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR;
&#x9;DECLARE explen1&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;INTEGER;
&#x9;DECLARE digestSeed&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;VARCHAR DEFAULT &apos;KPImetrics_S33D&apos;;

&#x9;set outString = inString;
&#x9;if (outString is not null and LENGTH(outString||&apos;*&apos;)-1 &gt; 0) then

&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||&apos;IN  ORIGINAL: codingType=[&apos;||NVL(codingType,&apos;null&apos;)||&apos;]  encodingActions=[&apos;||NVL(encodingActions,&apos;null&apos;)||&apos;]  codingList=[&apos;||NVL(codingList,&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||&apos;IN  ORIGINAL:   inString=[&apos;||NVL(SUBSTRING(inString,1,debugPrintSize),&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;end if;

&#x9;&#x9;-- Loop through the coding list
&#x9;&#x9;-- Extract the object from the list
&#x9;&#x9;SET objectList1 = codingList;
&#x9;&#x9;SET expression1 = &apos;,&apos;;
&#x9;&#x9;SET explen1 = length(expression1);
&#x9;&#x9;SET moreToDo1 = true;
&#x9;&#x9;SET x = 0;
&#x9;&#x9;WHILE (moreToDo1) DO
&#x9;&#x9;&#x9;-- Extract the source column type
&#x9;&#x9;&#x9;SET x = x + 1;
&#x9;&#x9;&#x9;SET object = null;
&#x9;&#x9;&#x9;IF (x = 1) THEN
&#x9;&#x9;&#x9;&#x9;SET pos1 = INSTR(objectList1, expression1, 1, x);
&#x9;&#x9;&#x9;&#x9;IF (pos1 &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;SET object = SUBSTRING(objectList1, 1, pos1-1);
&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;IF (LENGTH(TRIM(objectList1)) &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SET object = objectList1;
&#x9;&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;&#x9;&#x9;SET moreToDo1 = false;
&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;SET pos1 = INSTR(objectList1, expression1, 1, x-1);
&#x9;&#x9;&#x9;&#x9;SET pos2 = INSTR(objectList1, expression1, 1, x);
&#x9;&#x9;&#x9;&#x9;IF (pos1 &gt; 0 and pos2 &gt; 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;SET object = SUBSTRING(objectList1, pos1+explen1, pos2-pos1-explen1);
&#x9;&#x9;&#x9;&#x9;ELSEIF (pos1 &gt; 0 and pos2 = 0) THEN
&#x9;&#x9;&#x9;&#x9;&#x9;SET object = SUBSTRING(objectList1, pos1+explen1);
&#x9;&#x9;&#x9;&#x9;&#x9;SET moreToDo1 = false;
&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;SET moreToDo1 = false;
&#x9;&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;&#x9;SET object = UPPER(object); -- DO NOT TRIM
&#x9;&#x9;&#x9;--CALL PRINT(&apos;object=&apos;||NVL(object,&apos;null&apos;));
&#x9;&#x9;&#x9;IF (object IS NOT NULL) then
&#x9;&#x9;&#x9;&#x9;set codedValue = object;
&#x9;&#x9;&#x9;&#x9;set actualValue = null;

&#x9;&#x9;&#x9;&#x9;CASE codedValue
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN &apos;HEXADECIMAL&apos;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;&apos;&apos;&apos;;-- single quote
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedSpace &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos; &apos;;&#x9;-- _0020 = space
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedComma &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;,&apos;;&#x9;-- _002C = comma
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedPeriod &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;.&apos;;&#x9;-- _002E = period
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedPipe&#x9; &#x9;&#x9;&#x9;THEN set actualValue = &apos;|&apos;;&#x9;-- _007C = pipe
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedOpFact &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;!&apos;;&#x9;-- _0021 = factorial operator
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedDollar &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;$&apos;;&#x9;-- _0024 = dollar sign
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedOpMod &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;%&apos;;&#x9;-- _0025 = modulo operator
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedLParen &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;(&apos;;&#x9;-- _0028 = left parenthesis
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedRParen &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;)&apos;;&#x9;-- _0029 = right parenthesis
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedOpExponent&#x9;&#x9;&#x9;THEN set actualValue = &apos;**&apos;;-- _002A_002A = exponent operator
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedOpMult &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;*&apos;;&#x9;-- _002A = multiplication operator
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedOpAdd &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;+&apos;;&#x9;-- _002B = addition operator
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedOpSub &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;-&apos;;&#x9;-- _002D = substraction operator
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedOpDiv &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;/&apos;;&#x9;-- _002F = division operator
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedQuestionMark &#x9;&#x9;THEN set actualValue = &apos;?&apos;;&#x9;-- _003F = question mark
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedLeftBracket &#x9;&#x9;THEN set actualValue = &apos;[&apos;;&#x9;-- _005B = left square bracket
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedBackslash&#x9;&#x9;&#x9;THEN set actualValue = &apos;\&apos;;&#x9;-- _005C = backslash
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedRightBracket&#x9;&#x9;THEN set actualValue = &apos;]&apos;;&#x9;-- _005D = right square bracket
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedCarat &#x9;&#x9;&#x9;&#x9;THEN set actualValue = &apos;^&apos;;&#x9;-- _005E = carat
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedLeftCurlyBracket &#x9;THEN set actualValue = &apos;{&apos;;&#x9;-- _007B = left curly bracket
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedRightCurlyBracket &#x9;THEN set actualValue = &apos;}&apos;;&#x9;-- _007D = right curly bracket
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedSingleQuote &#x9;&#x9;THEN set actualValue = &apos;&apos;&apos;&apos;;-- _0027 = single quote
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedDoubleDoubleQuote &#x9;THEN set actualValue = &apos;&quot;&quot;&apos;;-- _0022_0022 = Double double quote
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedASUpperUpper&#x9;&#x9;THEN set actualValue = &apos; AS &apos;;-- [ _0041_0053 ] = AS 
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedASLowerLower&#x9;&#x9;THEN set actualValue = &apos; as &apos;;-- [ _0061_0073 ] = as 
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedASUpperLower&#x9;&#x9;THEN set actualValue = &apos; As &apos;;-- [ _0041_0073 ] = As 
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedASLowerUpper&#x9;&#x9;THEN set actualValue = &apos; aS &apos;;-- [ _0061_0053 ] = aS 
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedLineFeed&#x9;&#x9;&#x9;THEN set actualValue = CHR(10);-- _000A = LineFeed - LF
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedCarriageReturn&#x9;&#x9;THEN set actualValue = CHR(13);-- _000D = CarriageReturn - CR
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedCompOpNE1&#x9;&#x9;&#x9;THEN set actualValue = &apos;&lt;&gt;&apos;;-- _003C_003E = not equal type 1
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedCompOpNE2&#x9;&#x9;&#x9;THEN set actualValue = &apos;!=&apos;;-- _0021_003D = not equal type 2
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedCompOpGTE&#x9;&#x9;&#x9;THEN set actualValue = &apos;&gt;=&apos;;-- _003E_003D = greater than or equal
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedCompOpLTE&#x9;&#x9;&#x9;THEN set actualValue = &apos;&lt;=&apos;;-- _003C_003D = less than or equal
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedCompOpGT&#x9;&#x9;&#x9;THEN set actualValue = &apos;&gt;&apos;; -- _003E_0000 = greater than
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedCompOpLT&#x9;&#x9;&#x9;THEN set actualValue = &apos;&lt;&apos;; -- _0003C_0000 = less than
&#x9;&#x9;&#x9;&#x9;&#x9;WHEN /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/encodedValues.encodedCompOpEQ&#x9;&#x9;&#x9;THEN set actualValue = &apos;=&apos;; -- _003D_0000 = equal
&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;END CASE;

&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;call print(&apos;&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos;  BEGIN ACTION:  codingType=[&apos;||NVL(codingType,&apos;null&apos;)||&apos;]  encodingActions=[&apos;||NVL(encodingActions,&apos;null&apos;)||&apos;] codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]  actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;-- Perform an encoding of the string
&#x9;&#x9;&#x9;&#x9;/************************
&#x9;&#x9;&#x9;&#x9; * ENCODE codingType=&apos;E&apos;
&#x9;&#x9;&#x9;&#x9; ***********************/
&#x9;&#x9;&#x9;&#x9;if (codingType = &apos;E&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;select {OPTION CASE_SENSITIVE=&quot;TRUE&quot;} INSTR(outString, actualValue) into pos from /services/databases/system/DUAL;
&#x9;&#x9;&#x9;&#x9;&#x9;if (pos &gt; 0 OR codedValue = &apos;HEXADECIMAL&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;N&apos; IN encodingActions) = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (actualValue = &apos;&quot;&quot;&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actualValue = &apos;&quot;\&quot;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* ENCODE list of encoding values between left parens and right parens */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;P&apos; IN encodingActions) &gt; 0 AND (POSITION(&apos;(&apos; IN outString) &gt; 0 or POSITION(&apos;)&apos; IN outString) &gt; 0)) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (length(actualValue||&apos;*&apos;)-1 = 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = &apos;\&apos;||actualValue||regexReplacePatternParentheses;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = actualValue||regexReplacePatternParentheses;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actionType = &apos;ENCODE:P():   actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]  codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]&apos;;
/* Fix regex expression to handle multiple sets of parens and nested parens as in ( ( ( ( ) ) ) ( ) )
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- OPTION 1 - This will work with 1 pair of parens ( )
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- This will not work because the regex pattern used does not handle nested parenthesis ( ( ) ( ) ) 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Fix this and use this option for everything
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=[&apos;||NVL(regexPattern,&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/ASAssets/Utilities/string/TextUtils/RegexReplace(outString, regexPattern, codedValue, 0, outString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; actual=[&apos;||NVL(outString,&apos;&apos;)||&apos; outString=[&apos;||NVL(outString,&apos;&apos;)||&apos;]  regexPattern=&apos;||regexPattern);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
*/
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- OPTION 2 - brute force - find opening and closing parenthesis including nested and multiple separate sets of parens
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=N/A brute force method&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Patterns:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--&#x9;&#x9;F ( expr ) A
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--&#x9;&#x9;F ( F ( F ( expr ) ) ) || F ( F ( F ( expr) ) ) ) A
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- &#x9;&#x9;F ( F ( F ( F ( expr ) ) ) || F ( F ( F ( expr) ) ) ) ) A
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set pos = INSTR(outString,&apos;(&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (actualValue = &apos;&quot;\&quot;&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actualValue = &apos;&quot;&quot;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Search through the sql script to find the corresponding right paren ) for the starting left paren (
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = -1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos &gt; 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = SUBSTRING(outString, 1, pos-1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = pos;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;i=&apos;||i||&apos;  pos=&apos;||pos||&apos; outStringTemp=&apos;||outStringTemp);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (i &lt;= LENGTH(outString||&apos;*&apos;)-1) do
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set ch = substring(outString,i,1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch = &apos;(&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (parenCount &lt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = parenCount + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (leftPos = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = i;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch = &apos;)&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = parenCount - 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Perform the action on the paren pair
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (parenCount &lt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;i=&apos;||i||&apos; ch=[&apos;||ch||&apos;]  parenCount=&apos;||parenCount||&apos;  leftPos=&apos;||leftPos||&apos;  rightPos=&apos;||rightPos);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;outStringTemp=&apos;||outStringTemp);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (parenCount = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = i;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set tempString = SUBSTRING(outString, leftPos, rightPos - leftPos + 1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;i=&apos;||i||&apos; ch=[&apos;||ch||&apos;]  parenCount=&apos;||parenCount||&apos;  leftPos=&apos;||leftPos||&apos;  rightPos=&apos;||rightPos||&apos;  rightPos - leftPos + 1=&apos;||cast(rightPos - leftPos + 1 as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;tempString=&apos;||tempString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || REPLACE(tempString, actualValue, codedValue);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = -1; -- reset for a new pairing
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;parenCount=&apos;||parenCount||&apos;  outStringTemp=&apos;||outStringTemp);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- do nothing.  keep consuming characters
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = i + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end while;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outString = outStringTemp;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=N/A brute force method&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debugTime = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set duration = CURRENT_TIMESTAMP - startTime;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; codedValue=[&apos;||codedValue||&apos;] duration=&apos;||cast(duration as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* ENCODE list of encoding values between double quotes */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;D&apos; IN encodingActions) &gt; 0 AND POSITION(&apos;&quot;&apos; IN outString) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (length(actualValue||&apos;*&apos;)-1 = 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = &apos;\&apos;||actualValue||regexReplacePatternDoubleQuote;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = actualValue||regexReplacePatternDoubleQuote;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actionType = &apos;ENCODE:D&quot;&quot;:   actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]  codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;BEGIN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/TextUtils/RegexReplace(outString, regexPattern, codedValue, 0, outString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for x as select * from /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/extractDelimitedText(outString,&apos;&quot;&apos;,0,0,0,0,0) do
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = iterations + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (iterations % 2 = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- For even numbered lines add the double quotes back in and execute the RegexReplace pattern between the double quotes
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set  outStringTemp = outStringTemp || &apos;&quot;&apos;||REPLACE(x.object, actualValue, codedValue)||&apos;&quot;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- For odd numbered lines just add the original string back in
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || x.object;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end for;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outString = outStringTemp;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos;  iterations=&apos;||iterations||&apos;  outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=[&apos;||NVL(regexPattern,&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debugTime = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set duration = CURRENT_TIMESTAMP - startTime;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; codedValue=[&apos;||codedValue||&apos;] duration=&apos;||cast(duration as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* ENCODE list of encoding values between single quotes except when the encoded value is a single quote */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;S&apos; IN encodingActions) &gt; 0 AND POSITION(&apos;&apos;&apos;&apos; IN outString) &gt; 0 AND (actualValue != &apos;&apos;&apos;&apos; OR codedValue = &apos;HEXADECIMAL&apos;)) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actionType = &apos;ENCODE:S&apos;&apos;&apos;&apos;:   actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]  codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]&apos;;
/*  2017-03-07 mtinius: Have had too many stack overflows using RegexReplace. Removing code completely 
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Get the number of occurrences of the single quote
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/ASAssets/Utilities/string/numOccurrences(&apos;&apos;&apos;&apos;, outString, numOccurrences);

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = &apos;\&apos;||actualValue||regexReplacePatternSingleQuote;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (numOccurrences &lt;= regexOccurrenceMax) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/ASAssets/Utilities/string/TextUtils/RegexReplace(outString, regexPattern, codedValue, 0, outString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
*/
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* ENCODE list of HEXADECIMAL encoded values */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (codedValue = &apos;HEXADECIMAL&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : BRUTE FORCE METHOD: actionType=&apos;||NVL(actionType,&apos;null&apos;)||&apos;  length(outString)=&apos;||cast(length(outString||&apos;*&apos;)-1 as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set quoteCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (i &lt;= LENGTH(outString||&apos;*&apos;)-1) do
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set ch = substring(outString,i,1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch = &apos;&apos;&apos;&apos; and quoteCount = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set quoteCount = 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = i;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (ch = &apos;&apos;&apos;&apos; and quoteCount = 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set quoteCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = i;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set tempString = SUBSTRING(outString,leftPos+1, rightPos-leftPos-1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : BRUTE FORCE METHOD: tempString=&apos;||NVL(tempString,&apos;null&apos;));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;BEGIN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = iterations + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Encrypt the string.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/encoding/EncodingCJP/EncryptWith3DES(tempString, digestSeed, encryptedRawBytes, encryptedHex);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || encryptedHex;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- If it throws an error so just take the string as is
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || tempString;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Capture the character value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (quoteCount = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = i + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end while;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outString = outStringTemp;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else -- Encode with 5 character encoded value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : BRUTE FORCE METHOD: actionType=&apos;||NVL(actionType,&apos;null&apos;)||&apos;  length(outString)=&apos;||cast(length(outString||&apos;*&apos;)-1 as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set quoteCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (i &lt;= LENGTH(outString||&apos;*&apos;)-1) do
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set ch = substring(outString,i,1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch = &apos;&apos;&apos;&apos; and quoteCount = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set quoteCount = 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (ch = &apos;&apos;&apos;&apos; and quoteCount = 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set quoteCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Perform the action on the paren pair
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (quoteCount = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (quoteCount = 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch = actualValue) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || codedValue;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = i + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end while;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outString = outStringTemp;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos;  iterations=&apos;||iterations||&apos;  outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=[&apos;||NVL(regexPattern,&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debugTime = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set duration = CURRENT_TIMESTAMP - startTime;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; codedValue=[&apos;||codedValue||&apos;] duration=&apos;||cast(duration as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* ENCODE list of encoding values anywhere in the string */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;N&apos; IN encodingActions) &gt; 0 AND POSITION(actualValue IN outString) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (length(actualValue||&apos;*&apos;)-1 = 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = &apos;\&apos;||actualValue;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = actualValue;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actionType = &apos;ENCODE:N:&lt;ANY&gt;:   actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]  codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/TextUtils/RegexReplace(outString, regexPattern, codedValue, 0, outString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=[&apos;||NVL(regexPattern,&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debugTime = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set duration = CURRENT_TIMESTAMP - startTime;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; codedValue=[&apos;||codedValue||&apos;] duration=&apos;||cast(duration as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;/************************
&#x9;&#x9;&#x9;&#x9; * DECODE codingType=&apos;D&apos;
&#x9;&#x9;&#x9;&#x9; ***********************/
&#x9;&#x9;&#x9;&#x9;-- Perform a decoding of the string
&#x9;&#x9;&#x9;&#x9;&#x9;if (INSTR(outString, codedValue) &gt; 0 OR codedValue = &apos;HEXADECIMAL&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- If the encoding action is &quot;NOT&quot; N and the actualValue is in the escape list for actualValues then escape it otherwise don&apos;t
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;N&apos; IN encodingActions) = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(actualValue IN escapeValueList) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (actualValue = &apos;&quot;&quot;&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actualValue = &apos;\&quot;\&quot;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actualValue = &apos;\&apos;||actualValue;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* DECODE list of encoding values between left and right parens */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;P&apos; IN encodingActions) &gt; 0 AND (POSITION(&apos;(&apos; IN outString) &gt; 0 OR POSITION(&apos;)&apos; IN outString) &gt; 0) ) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = codedValue||regexReplacePatternParentheses;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actionType = &apos;DECODE:P():     codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]  actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]&apos;;
/* Fix regex expression to handle multiple sets of parens and nested parens as in ( ( ( ( ) ) ) ( ) )
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/ASAssets/Utilities/string/TextUtils/RegexReplace(outString, regexPattern, actualValue, 0, outString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; actual=[&apos;||NVL(outString,&apos;&apos;)||&apos;]  outString=[&apos;||NVL(outString,&apos;&apos;)||&apos;]  regexPattern=&apos;||regexPattern);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
*/
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- OPTION 2 - brute force - find opening and closing parenthesis including nested and multiple separate sets of parens
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Patterns:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--&#x9;&#x9;F ( expr ) A
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--&#x9;&#x9;F ( F ( F ( expr ) ) ) || F ( F ( F ( expr) ) ) ) A
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- &#x9;&#x9;F ( F ( F ( F ( expr ) ) ) || F ( F ( F ( expr) ) ) ) ) A
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set pos = INSTR(outString,&apos;(&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (actualValue = &apos;\&quot;\&quot;&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actualValue = &apos;&quot;&quot;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (INSTR(actualValue,&apos;\&apos;) = 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actualValue = SUBSTRING(actualValue,2);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actionType = &apos;DECODE:P():     codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]  actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Search through the sql script to find the corresponding right paren ) for the starting left paren (
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = -1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (pos &gt; 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = SUBSTRING(outString, 1, pos-1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = pos;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (i &lt;= LENGTH(outString||&apos;*&apos;)-1) do
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set ch = substring(outString,i,1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch = &apos;(&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (parenCount &lt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = parenCount + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (leftPos = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = i;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch = &apos;)&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = parenCount - 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Perform the action on the paren pair
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (parenCount &lt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;parenCount=&apos;||parenCount||&apos;  outStringTemp=&apos;||outStringTemp);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (parenCount = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = i;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set tempString = SUBSTRING(outString, leftPos, rightPos - leftPos + 1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;tempString=&apos;||tempString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || REPLACE(tempString, codedValue, actualValue);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;leftPos=&apos;||leftPos||&apos;  rightPos=&apos;||rightPos||&apos;  rightPos - leftPos + 1=&apos;||cast(rightPos - leftPos + 1 as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set parenCount = -1; -- reset for a new pairing
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--call print(&apos;parenCount=&apos;||parenCount||&apos;  outStringTemp=&apos;||outStringTemp);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- do nothing.  keep consuming characters
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = i + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end while;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outString = outStringTemp;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; actual=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=N/A brute force method&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debugTime = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set duration = CURRENT_TIMESTAMP - startTime;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; codedValue=[&apos;||codedValue||&apos;] duration=&apos;||cast(duration as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* DECODE list of encoding values between Double Quotes */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;D&apos; IN encodingActions) &gt; 0 AND POSITION(&apos;&quot;&apos; IN outString) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = codedValue||regexReplacePatternDoubleQuote;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actionType = &apos;DECODE:D&quot;&quot;:     codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]  actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;BEGIN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/TextUtils/RegexReplace(outString, regexPattern, actualValue, 0, outString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for x as select * from /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/extractDelimitedText(outString,&apos;&quot;&apos;,0,0,0,0,0) do
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = iterations + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (iterations % 2 = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- For even numbered lines add the double quotes back in and execute the REPLACE pattern between the double quotes
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set  outStringTemp = outStringTemp || &apos;&quot;&apos;||REPLACE(x.object, codedValue, actualValue)||&apos;&quot;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- For odd numbered lines just add the original string back in
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || x.object;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end for;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outString = outStringTemp;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos;  iterations=&apos;||iterations||&apos;  outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=[&apos;||NVL(regexPattern,&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debugTime = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set duration = CURRENT_TIMESTAMP - startTime;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; codedValue=[&apos;||codedValue||&apos;] duration=&apos;||cast(duration as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* DECODE list of encoding values between single quotes except when the encoded value is a single quote */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;S&apos; IN encodingActions) &gt; 0 AND POSITION(&apos;&apos;&apos;&apos; IN outString) &gt; 0 AND (actualValue != &apos;&apos;&apos;&apos; OR codedValue = &apos;HEXADECIMAL&apos;)) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actionType = &apos;DECODE:S&apos;&apos;&apos;&apos;:     codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]  actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* DECODE list of HEXADECIMAL encoded values */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (codedValue = &apos;HEXADECIMAL&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = codedValue;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : BRUTE FORCE METHOD: actionType=&apos;||NVL(actionType,&apos;null&apos;)||&apos;  length(outString)=&apos;||cast(length(outString||&apos;*&apos;)-1 as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set quoteCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = &apos;&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (i &lt;= LENGTH(outString||&apos;*&apos;)-1) do
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set ch = substring(outString,i,1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (ch = &apos;&apos;&apos;&apos; and quoteCount = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set quoteCount = 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set leftPos = i;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;elseif (ch = &apos;&apos;&apos;&apos; and quoteCount = 1) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set quoteCount = 0;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set rightPos = i;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set encryptedHex = SUBSTRING(outString,leftPos+1, rightPos-leftPos-1);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : BRUTE FORCE METHOD: encryptedHex=&apos;||NVL(encryptedHex,&apos;null&apos;));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;BEGIN
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set iterations = iterations + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Decrypt the string.
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/encoding/EncodingCJP/DecryptFrom3DES(encryptedHex, digestSeed, tempString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || tempString;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;EXCEPTION
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ELSE
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- The string is not encrypted if it throws an error so just take the string as is
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || encryptedHex;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;END;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;-- Capture the character value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (quoteCount = 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outStringTemp = outStringTemp || ch;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set i = i + 1;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end while;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outString = outStringTemp;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else -- Decode with 5 character encoded value
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = codedValue||regexReplacePatternSingleQuote;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/string/TextUtils/RegexReplace(outString, regexPattern, actualValue, 0, outString);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos;  iterations=&apos;||iterations||&apos;  actual=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=[&apos;||NVL(regexPattern,&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debugTime = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set duration = CURRENT_TIMESTAMP - startTime;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; codedValue=[&apos;||codedValue||&apos;] duration=&apos;||cast(duration as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;

&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;/* DECODE list of encoding values anywhere in the string */
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (POSITION(&apos;N&apos; IN encodingActions) &gt; 0 AND POSITION(codedValue IN outString) &gt; 0) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set regexPattern = codedValue;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set actionType = &apos;DECODE:N&lt;ANY&gt;:     codedValue=[&apos;||NVL(codedValue,&apos;null&apos;)||&apos;]  actualValue=[&apos;||NVL(actualValue,&apos;null&apos;)||&apos;]&apos;;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set outString = REPLACE(outString, regexPattern, actualValue);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; actual=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]  regexPattern=[&apos;||NVL(regexPattern,&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (debugTime = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;set duration = CURRENT_TIMESTAMP - startTime;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos; &apos;||NVL(actionType,&apos;null&apos;)||&apos; codedValue=[&apos;||codedValue||&apos;] duration=&apos;||cast(duration as varchar));
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;&#x9;end if;
&#x9;&#x9;&#x9;END IF;
&#x9;&#x9;END WHILE;

&#x9;&#x9;if (actionType = defaultActionType) then
&#x9;&#x9;&#x9;if (debug = &apos;Y&apos;) then
&#x9;&#x9;&#x9;&#x9;call print(moduleName||&apos; : &apos;||NVL(actionType,&apos;null&apos;)||&apos; outString=[&apos;||NVL(SUBSTRING(outString,1,debugPrintSize),&apos;null&apos;)||&apos;]&apos;);
&#x9;&#x9;&#x9;end if;
&#x9;&#x9;end if;
&#x9;end if;
&#x9;if (debugTime = &apos;Y&apos;) then
&#x9;&#x9;call /shared/Delta_DV/&quot;_scripts&quot;/Utilities/&quot;time&quot;/getCurrentTimestamp(endTime);
&#x9;&#x9;set duration = endTime - startTime;
&#x9;&#x9;call print(moduleName||&apos; : &lt;--&apos;||NVL(moduleNameInvoking||&apos;-&apos;,&apos;null&apos;)||NVL(inModuleQualifer,&apos;null&apos;)||&apos;: [&apos;||NVL(inCodingType,&apos;null&apos;)||&apos;]  [&apos;||NVL(inEncodingActions,&apos;null&apos;)||&apos;]  [&apos;||NVL(codingList,&apos;null&apos;)||
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&apos;]  overall duration=&apos;||cast(duration as varchar));
&#x9;end if;
END</attribute>
  <attribute name="creationDate" type="LONG">0</attribute>
  <attribute name="creatorUserDomain" type="STRING"/>
  <attribute name="creatorUserName" type="STRING"/>
  <attribute name="explicitly.designed" type="BOOLEAN">false</attribute>
  <attribute name="lastModifiedDate" type="LONG">1609965948495</attribute>
  <attribute name="lastModifiedUserDomain" type="STRING">composite</attribute>
  <attribute name="lastModifiedUserName" type="STRING">admin</attribute>
  <attribute name="model" type="NULL"/>
  <attribute name="native_only" type="STRING">false</attribute>
  <attribute name="p:1:Customized" type="STRING">datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed;datatype.changed</attribute>
  <attribute name="references" type="MAP">
    <item>
      <key type="STRING">15/408</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">15/602</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/440</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/462</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/342</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/661</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">15/366</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/586</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/246</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/444</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/346</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/665</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/306</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/647</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/122</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">9/123</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/207</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">11/208</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/590</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">17/620</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">8/682</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/310</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/651</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/554</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/458</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">17/384</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">14/558</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
    <item>
      <key type="STRING">10/675</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>debug</item>
        <item>Print</item>
      </value>
    </item>
  </attribute>
</metadata>